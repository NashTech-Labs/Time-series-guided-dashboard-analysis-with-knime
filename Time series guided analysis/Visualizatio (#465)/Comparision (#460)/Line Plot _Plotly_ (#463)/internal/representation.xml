<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="viewRepresentation">
<entry key="jsNamespace" type="xstring" value="knimePlotlyLinePlot"/>
<config key="jsCode">
<entry key="array-size" type="xint" value="2"/>
<entry key="0" type="xstring" value="/**%%00010 * KnimePlotlyInterface is the utility file that abstracts much of the%%00010 * functionality from the Plotly nodes. Its main purposes are:%%00010 * %%00010 *      - Converting the JSONDataTable (kt) from a row-based format to%%00010 *        a columnar format which is more performant with the Plotly%%00010 *        library.%%00010 *      - Indexing the data into &quot;Traces&quot; which are collections of related%%00010 *        points or rows usually partitioned based on the &quot;groupBy&quot; column%%00010 *        (except for the radar plot which has a trace per row).%%00010 *      - Storing ordered indicies for line based plots.%%00010 *      - Storing updated indicies for styling selected points.%%00010 *      - Storing the &quot;selected&quot; and &quot;filtered&quot; state of the views.%%00010 *      - Providing the functionality to consume filter and selection events%%00010 *        and create Plotly &quot;update&quot; Objects to enable interactivity.%%00010 *      - Providing utility methods such as converting color string formats%%00010 *        or reordering the data when new features are selected.%%00010 * %%00010 * Each Plotly node should have a KPI instance which consumes the data and the%%00010 * settings. The Knime JS Views framework methods should all be accessed through%%00010 * the KPI instance of each Plotly node (such as getSVG, getComponentValue, etc).%%00010 */%%00010window.KnimePlotlyInterface = function () {%%00010%%00010    /**%%00010     * Version 1.0.0: original implementation%%00010     * Version 1.0.1: documentation added%%00010     */%%00010    var KnimePlotlyInterface = {%%00010        version: '1.0.1'%%00010    };%%00010%%00010    /**%%00010     * The *init* method is closely linked to the instantiation of the KPI%%00010     * and should be called 2nd in the lifecyle of a KPI instance. This %%00010     * method established many of the internal fields as well as maps%%00010     * the input JSON data table into a columnar, indexed format which%%00010     * is much better suited for Plotly integration. It also sets any %%00010     * warning messages regarding missing values and, finally, clears%%00010     * out the in-memory references to the rows in the *kt* instance %%00010     * to improve performance.%%00010     * %%00010     * @param  {Object} rep the viewRepresentation configuration object%%00010     * @param  {Object} val the ViewValue configuration object%%00010     * @param  {Object} knimeDataTable the kt (knimeDataTable.js) instance%%00010     * @param  {array} args the array of libraries holding the Plotly and (if %%00010     *      applicable) moment.js libraries.%%00010     */%%00010    KnimePlotlyInterface.initialize = function (rep, val, knimeDataTable, args) {%%00010%%00010        var self = this;%%00010        this.representation = rep;%%00010        this.value = val;%%00010        this.table = knimeDataTable;%%00010        if (typeof args[2] === 'undefined') {%%00010            this.Plotly = args[0];%%00010        } else {%%00010            this.moment = args[0];%%00010            this.Plotly = args[2];%%00010        }%%00010        this.table.setDataTable(this.representation.inObjects[0]);%%00010        this.columns = knimeDataTable.getColumnNames();%%00010        this.rowColors = knimeDataTable.getRowColors();%%00010        this.rowDirectory = {};%%00010        this.filtered = new this.KSet([]);%%00010        this.selected = new this.KSet([]);%%00010        this.traceDirectory = [];%%00010        this.changeObjKeys = [];%%00010        this.orderedIndicies = [];%%00010        this.totalRows = 0;%%00010        this.totalSelected = 0;%%00010        this.isOrdered = false;%%00010        this.showOnlySelected = false;%%00010        this.isSurface = false;%%00010        this.rotatedTicks = false;%%00010        this.onlySelectedBehavior = 'normal'; // important for custom selection behavior%%00010        this.lastSOSState = false;  // important for custom selection behavior ('violin')%%00010        this.mValues = val.options.mValues.replace(/\s/g, ' ') === 'Skip rows with missing values' ? 0 : 1;%%00010        this.mRows = new this.KSet([]);%%00010        this.data = {%%00010            rowKeys: [],%%00010            rowColors: []%%00010        };%%00010%%00010        this.columns.forEach(function (column) {%%00010            self.data[column] = [];%%00010        });%%00010%%00010        if (this.representation.options.overrideColors) {%%00010            this.rowColors = [];%%00010        }%%00010%%00010        var rows = knimeDataTable.getRows();%%00010%%00010        rows.forEach(function (row, rowInd) {%%00010%%00010            var skipRow = false;%%00010            var totalPush = 0;%%00010%%00010            row.data.forEach(function (data, dataInd) {%%00010                if (skipRow) {%%00010                    return;%%00010                }%%00010                if (data === null) {%%00010                    if (rep.options.reportMissing) {%%00010                        self.mRows.add(row.rowKey);%%00010                    }%%00010                    if (self.mValues === 0) {%%00010                        skipRow = true;%%00010                        return;%%00010                    }%%00010                }%%00010                totalPush++;%%00010                self.data[self.columns[dataInd]].push(data);%%00010            });%%00010%%00010            if (skipRow) {%%00010                // remove partially inserted rows with missing values%%00010                for (var i = 0; i &lt; totalPush; i++) {%%00010                    self.data[self.columns[i]].splice(self.data[self.columns[i]].length - 1, 1);%%00010                }%%00010                return;%%00010            }%%00010%%00010            if (self.rowColors.length &lt; rows.length ||%%00010                self.representation.options.overrideColors) {%%00010                self.rowColors.push(self.representation.options.dataColor);%%00010            }%%00010%%00010            self.rowDirectory[row.rowKey] = {%%00010                tInds: [],%%00010                pInd: self.data.rowColors.push(self.rowColors[rowInd]) - 1%%00010            };%%00010%%00010            self.data.rowKeys.push(row.rowKey);%%00010            self.filtered.add(row.rowKey);%%00010            self.totalRows++;%%00010        });%%00010%%00010        if (rep.options.reportMissing &amp;&amp; this.mRows.size() &gt; 0 &amp;&amp; val.options.showWarnings) {%%00010            if (self.mValues === 0) {%%00010                knimeService.setWarningMessage('There were missing values in this dataset. They have been removed from the ' +%%00010                    ' results. Total rows with missing values (removed): ' + this.mRows.size());%%00010            } else {%%00010                knimeService.setWarningMessage('There are missing values in this dataset! Total rows with missing values: ' +%%00010                    this.mRows.size() + '. Please use caution when interpreting results.');%%00010            }%%00010        }%%00010%%00010        this.collectGarbage();%%00010%%00010        return this;%%00010    };%%00010%%00010    /**%%00010     * This method initializes the visual elements in the DOM for the first time%%00010     * in the lifecycle of a Plotly js node. The parameters passed from the Parent%%00010     * chart contain all of the data, configuration, and settings for the view.%%00010     * This method also indexes the traces and creates the internal trace directory. %%00010     * %%00010     * @param  {array[...Object]} traceArr the array of trace data objects to chart%%00010     * @param  {Object} layout the Plotly layout object%%00010     * @param  {} config the Plotly config object%%00010     */%%00010    KnimePlotlyInterface.drawChart = function (traceArr, layout, config) {%%00010        if (this.representation.options.enableGL &amp;&amp; this.representation.runningInView) {%%00010            traceArr.forEach(function (trace) {%%00010                if (trace.type) {%%00010                    trace.type += 'gl';%%00010                }%%00010            });%%00010        }%%00010        this.indexTraces(traceArr);%%00010        var layoutObj = layout;%%00010        if (traceArr[0] &amp;&amp; traceArr[0].y) {%%00010            layoutObj = this.updateTicks(traceArr[0], layout);%%00010        }%%00010        if (!this.representation.options.enableSelection) {%%00010            if (typeof config.modeBarButtonsToRemove === 'undefined') {%%00010                config.modeBarButtonsToRemove = [];%%00010            }%%00010            var selectionButtons = ['lasso2d', 'select2d'];%%00010            selectionButtons.forEach(function (selBut) { config.modeBarButtonsToRemove.push(selBut); });%%00010        }%%00010        this.Plotly.newPlot(this.divID, traceArr, layoutObj, config);%%00010        if (this.representation.options.enableSelection) {%%00010            if (this.value.options.selectedrows &amp;&amp; this.value.options.selectedrows.length &gt; 0) {%%00010                this.totalSelected = this.value.options.selectedrows.length;%%00010                this.selected = new this.KSet(this.value.options.selectedrows);%%00010                this.update();%%00010            }%%00010        }%%00010    };%%00010%%00010    /**%%00010     * This method can be called by the parent chart to retrieve the SVG image%%00010     * from the view. It has multiple branches of logic, because some charts %%00010     * have different DOM elements and the Plotly SVG API is undocumented,%%00010     * so this method serves as a workaround and likely will need continual%%00010     * updates as new charts are introduced. It also does not currently supprt%%00010     * 3D charts.%%00010     * %%00010     * @returns {String} the SVG string from the view%%00010     */%%00010    KnimePlotlyInterface.getSVG = function () {%%00010        var self = this;%%00010        var h = this.representation.options.svg.height;%%00010        var w = this.representation.options.svg.width;%%00010        var mainAxisClips = document.querySelectorAll('.xy');%%00010        mainAxisClips.forEach(function (clipObj) {%%00010            clipObj.childNodes.forEach(function (node) {%%00010                node.style.fill = self.representation.options.backgroundColor;%%00010            });%%00010        });%%00010        var secondAxisClips = document.querySelectorAll('.xy2');%%00010        if (secondAxisClips &amp;&amp; secondAxisClips.length &amp;&amp; secondAxisClips.length &gt; 0) {%%00010            secondAxisClips.forEach(function (clipObj) {%%00010                clipObj.childNodes.forEach(function (node) {%%00010                    node.style.fill = self.representation.options.backgroundColor;%%00010                });%%00010            });%%00010        }%%00010        var thirdAxisClips = document.querySelectorAll('.x2y');%%00010        if (thirdAxisClips &amp;&amp; thirdAxisClips.length &amp;&amp; thirdAxisClips.length &gt; 0) {%%00010            thirdAxisClips.forEach(function (clipObj) {%%00010                clipObj.childNodes.forEach(function (node) {%%00010                    node.style.fill = self.representation.options.backgroundColor;%%00010                });%%00010            });%%00010        }%%00010        var polarClips = document.querySelector('.polarsublayer');%%00010        if (polarClips &amp;&amp; polarClips.children.length &amp;&amp; polarClips.children.length &gt; 0) {%%00010            polarClips.childNodes.forEach(function (pathChild) {%%00010                pathChild.style.fill = self.representation.options.backgroundColor;%%00010            });%%00010        }%%00010        var svgElem = document.querySelectorAll('#' + this.divID + '&gt; div &gt; div &gt; svg');%%00010        var svgCol = '&lt;svg class=&quot;main-svg&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;' +%%00010            ' xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;' + w +%%00010            '&quot; height=&quot;' + h + '&quot;&gt;' +%%00010            '&quot;&gt;&lt;g xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;rect width=&quot;' + w + '&quot; height=&quot;' +%%00010            h + '&quot; style=&quot;fill: ' +%%00010            this.representation.options.backgroundColor + ';width:' + w + 'px;height:' +%%00010            h + 'px&quot;&gt;&lt;/rect&gt;&lt;/g&gt;';%%00010        svgElem.forEach(function (svg, svgInd) {%%00010            if (svg.tagName === 'svg') {%%00010                knimeService.inlineSvgStyles(svg);%%00010                svgCol += new XMLSerializer().serializeToString(svg);%%00010            }%%00010        });%%00010        svgCol += '&lt;/svg&gt;';%%00010        return svgCol;%%00010    };%%00010%%00010    /**%%00010     * Similar to the method of the same name in all JS-Knime views%%00010     * this method is called by the parent chart and retrieves the %%00010     * updated chart state to be used and saved inside the node.%%00010     * %%00010     * @returns {Object} the ViewValue to be returned to the AP%%00010     */%%00010    KnimePlotlyInterface.getComponentValue = function () {%%00010        var self = this;%%00010        var selectedObj = {};%%00010        Object.keys(this.rowDirectory).forEach(function (rowKey) {%%00010            selectedObj[rowKey] = self.selected.has(rowKey);%%00010        });%%00010        this.value.outColumns = {%%00010            selection: selectedObj%%00010        };%%00010        return this.value;%%00010    };%%00010%%00010    /**%%00010     * Setter method for the surface chart flag which is used %%00010     * to comply with Plotly specifications in the %%00010     * getFilteredChangeObj method. Surface chart is special%%00010     * because it supports no selection.%%00010     * %%00010     * @param  {boolean} bool true only for Surface chart%%00010     */%%00010    KnimePlotlyInterface.setIsSurface = function (bool) {%%00010        this.isSurface = bool;%%00010    };%%00010%%00010    /**%%00010     * This method is used to change the showOnlySelectd behavior%%00010     * for the 'violin' chart currently. It could be used in the%%00010     * future to enable more special behavior for other charts.%%00010     * %%00010     * The two expected values for the field currently are 'normal'%%00010     * and 'violin'.%%00010     * %%00010     * @param  {String} str the String value for onlySelectedBehavior%%00010     */%%00010    KnimePlotlyInterface.setOnlySelectedBehavior = function (str) {%%00010        this.onlySelectedBehavior = str;%%00010    };%%00010%%00010    /**%%00010     * This method creates the Plotly target element in the DOM and%%00010     * also handles the SVG/Image size, if necessary.%%00010     * %%00010     * @param  {String} stringDivName the name of the HTML div ID%%00010     *      which will contain the Plotly chart.%%00010     */%%00010    KnimePlotlyInterface.createElement = function (stringDivName) {%%00010        this.divID = stringDivName;%%00010        // Create the plotly HTML element%%00010        var divElem = document.createElement('div');%%00010        if (this.representation.options.svg &amp;&amp;%%00010            (!this.representation.options.svg.fullscreen || !this.representation.runningInView)) {%%00010            var dimString = 'width:' + this.representation.options.svg.width + 'px;height:' +%%00010                this.representation.options.svg.height + 'px';%%00010            divElem.setAttribute('style', dimString);%%00010        }%%00010        divElem.setAttribute('id', stringDivName);%%00010        document.body.appendChild(divElem);%%00010    };%%00010%%00010    /**%%00010     * This method is called after the KPI initialization and returns%%00010     * an Object full of arrays containing the data needed for traces%%00010     * by the Plotly API. The provided keys correspond to available data%%00010     * attributes, either actual column names from the data table, 'rowKeys'%%00010     * or 'rowColors'. The data returned is binned if there is grouping %%00010     * information available. See the example below of the structure:%%00010     * %%00010     *                        TRACE NUMBER%%00010     * return obj {             #1,   etc...%%00010     *      &quot;Universe0_0&quot; : [[0, ...], ...],     %%00010     *      .%%00010     *      .%%00010     *      .%%00010     *      &quot;rowKeys&quot; : [['rowID_0', ...], ...]%%00010     *  }%%00010     * %%00010     * The data returned is then used to create the initial trace objects%%00010     * for initializing the Plot (they will be passed into the drawChart%%00010     * method). Its important that the data is retrieved for each chart%%00010     * in this way because the trace data objects are different for all%%00010     * Plotly nodes.%%00010     * %%00010     * @param  {Object} keys the object containing the data keys %%00010     *  and their plotly equivalent and their corresponding Plotly keys%%00010     */%%00010    KnimePlotlyInterface.getData = function (keys) {%%00010        var self = this;%%00010        if (!this.changeKeys) {%%00010            this.updateKeys(keys);%%00010        }%%00010        var keySet = new this.KSet(keys.dataKeys).getArray();%%00010        var groupIndicies = [];%%00010        var groupLocations = {};%%00010        var obj = {%%00010            names: [],%%00010            rowKeys: []%%00010        };%%00010%%00010        keySet.forEach(function (key) {%%00010            obj[key] = [];%%00010        });%%00010%%00010        var count = 0;%%00010        if (this.representation.options.groupByColumn &amp;&amp; this.representation.options.groupByColumn !== 'none') {%%00010            self.data[this.representation.options.groupByColumn].forEach(function (group, groupInd) {%%00010                if (typeof groupLocations[group] === 'undefined') {%%00010                    groupLocations[group] = count;%%00010                    groupIndicies.push(count);%%00010                    keySet.forEach(function (key) {%%00010                        obj[key].push([]);%%00010                    });%%00010                    obj.names.push(group || 'Missing');%%00010                    count++;%%00010                } else {%%00010                    groupIndicies.push(groupLocations[group]);%%00010                }%%00010            });%%00010        } else {%%00010            groupIndicies = this.data.rowKeys.map(function (val, valInd) { return 0; });%%00010            keySet.forEach(function (key) {%%00010                obj[key].push([]);%%00010                if (!self.data[key]) {%%00010                    self.data[key] = groupIndicies.map(function () { return 'Data Set'; });%%00010                }%%00010            });%%00010            obj.names.push(['Data']);%%00010        }%%00010%%00010        groupIndicies.forEach(function (indArr, gInd) {%%00010            keySet.forEach(function (key) {%%00010                if (self.data[key]) {%%00010                    obj[key][indArr].push(self.data[key][gInd]);%%00010                }%%00010            });%%00010        });%%00010%%00010        if (this.isOrdered) {%%00010            obj.rowKeys.forEach(function (group, groupInd) {%%00010                keySet.forEach(function (key) {%%00010                    obj[key][groupInd] = self.getOrderedArray(obj[key][groupInd]);%%00010                });%%00010            });%%00010        }%%00010        return obj;%%00010    };%%00010%%00010    /**%%00010     * This internal method is called during the invocation of the drawChart%%00010     * method in the second stage of the KPI lifecycle. It consumes the%%00010     * array of trace objects created to Plotly specifications in the %%00010     * parent chart. It then creates the internally stored TraceDirectory%%00010     * for each of the provided traces (with a TraceMap instance) and maps%%00010     * the data keys for each trace to the TraceMap instance.%%00010     * %%00010     * @param  {array[Object]} incomingTraces an array of Plotly compliant%%00010     *      trace objects.%%00010     */%%00010    KnimePlotlyInterface.indexTraces = function (incomingTraces) {%%00010        var self = this;%%00010        // create an array to hold out trace objects%%00010        this.traceDirectory = [];%%00010        incomingTraces.forEach(function (singleTrace, traceInd) {%%00010            singleTrace.ids.forEach(function (rowId) {%%00010                self.rowDirectory[rowId].tInds.push(traceInd);%%00010            });%%00010            self.traceDirectory[traceInd] = new self.TraceMap(singleTrace.ids);%%00010            self.traceDirectory[traceInd].dataKeys = singleTrace.dataKeys;%%00010        });%%00010    };%%00010%%00010    /**%%00010     * This method is used to get an array of arrays for a single trace%%00010     * containing the indicies (in the Plotly trace) of selected points.%%00010     * The returned array should be used in a ChangeObj as the %%00010     * [selectedpoints] value when updating a Plotly chart. The indicies%%00010     * themselves come from the KPI instance [traceDirectory] which holds%%00010     * a TraceMap instance for each of the traces on the chart. This has%%00010     * rowKeys mapped to the most updated point indicies as far as Plotly%%00010     * is concerned, which is why we use them to update the style of the%%00010     * chart to reflect selection.%%00010     * %%00010     * @returns {array[array]} an array of arrays: 1 for each trace in%%00010     *      the chart scope, each containing the point indicies of the%%00010     *      selected points.%%00010     */%%00010    KnimePlotlyInterface.getSelectedPoints = function () {%%00010        var self = this;%%00010        var selectedPoints = [];%%00010%%00010        this.traceDirectory.forEach(function () {%%00010            var emptySelection = self.totalSelected &gt; 0 ? [] : null;%%00010            selectedPoints.push(emptySelection);%%00010        });%%00010        this.selected.getArray().forEach(function (rowKey) {%%00010            self.rowDirectory[rowKey].tInds.forEach(function (tInd) {%%00010                if (self.traceDirectory[tInd][rowKey] &gt; -1) {%%00010                    selectedPoints[tInd].push(self.traceDirectory[tInd][rowKey]);%%00010                }%%00010            });%%00010        });%%00010%%00010        return selectedPoints;%%00010    };%%00010%%00010    /**%%00010     * Likely the most important method in the KPI, this is used to %%00010     * get all updated data required to update the chart visuals.%%00010     * This method can be used without a parameter, in which case it%%00010     * will return the most update data with all of the specified%%00010     * keys (set through the updateKeys method). It can also be passed%%00010     * specific keys to just retrieve single feature changeObj (like %%00010     * retrieving updated colors or ids).%%00010     * %%00010     * This method returns a Plotly-compliant JavaScript object as%%00010     * seen here:%%00010     * %%00010     * EXAMPLE CHANGEOBJ%%00010     * %%00010     * var changeObj = {%%00010     *      'x' = [[0,1,...], [...], ...], //one array per trace%%00010     *      'y' = [[...], ...], //literal keys when possible%%00010     *      ['marker.color'] = [[...], ...], //key variables when not%%00010     *      marker = {%%00010     *          'selectpoints' = [null, [1,2,...], []] //null values for%%00010     *      }                                          //no change, empty%%00010     *  }                                              //[] for no data%%00010     * %%00010     * This JavaScript object structure is *central* to the Plotly API%%00010     * and is referenced again and again in the KPI. For more information%%00010     * on possible keys, etc. please reference: https://plot.ly%%00010     * %%00010     * This method also uses internal state to dynamically determine which%%00010     * data should be visible in the parent chart. If points are excluded%%00010     * via filter, they will not be represented in the returned object. The%%00010     * same goes for charts which support showing only selected points. This%%00010     * behavior is treated like a filter in implementation and the data is%%00010     * actually ommited from the ChangeObj instead of being published.%%00010     * %%00010     * Lastly, there is Surface chart specific code to re-box the 'z' axis%%00010     * data into another container array to comply with Plotly specs.%%00010     * %%00010     * @param  {array (optional)} keys to retrieve the most updated data%%00010     * @returns {Object} changeObj the filtered changeObj for updating%%00010     */%%00010    KnimePlotlyInterface.getFilteredChangeObject = function (keys) {%%00010        var self = this;%%00010        var changeObj = {};%%00010        // var dataKeys = keys ? keys.dataKeys : this.dataKeys;%%00010        var changeKeys = keys ? keys.plotlyKeys : this.changeObjKeys;%%00010%%00010        changeKeys.forEach(function (keys) {%%00010            keys.forEach(function (key) {%%00010                changeObj[key] = [];%%00010                self.traceDirectory.forEach(function () {%%00010                    changeObj[key].push([]);%%00010                });%%00010            });%%00010        });%%00010%%00010        if (self.isOrdered) {%%00010            var orderedRowKeys = this.getOrderedArray(this.data.rowKeys);%%00010            var count = 0;%%00010            self.traceDirectory.forEach(function (trace, traceInd) {%%00010                orderedRowKeys.forEach(function (rowKey, rowInd) {%%00010                    if (typeof trace[rowKey] === 'undefined') {%%00010                        return;%%00010                    }%%00010                    if ((self.showOnlySelected &amp;&amp; !self.selected.has(rowKey)) || !self.filtered.has(rowKey)) {%%00010                        self.traceDirectory[traceInd][rowKey] = -1;%%00010                        return;%%00010                    }%%00010                    var zData = changeObj.z || [[]];%%00010                    trace.dataKeys.forEach(function (key, keyInd) {%%00010                        if (self.isSurface &amp;&amp; keyInd &lt; 2) {%%00010                            if (keyInd === 0) {%%00010                                zData[0][count] = self.data[key][self.orderedIndicies[rowInd]];%%00010                                trace[rowKey] = count;%%00010                            } else {%%00010                                key.forEach(function (vCol, vColInd) {%%00010                                    var vectorData = zData[vColInd] || [];%%00010                                    vectorData[count] = self.data[vCol][self.orderedIndicies[rowInd]];%%00010                                    zData[vColInd] = vectorData;%%00010                                });%%00010                                changeObj.z = zData;%%00010                            }%%00010                        } else {%%00010                            changeKeys[keyInd].forEach(function (plotlyKey) {%%00010                                trace[rowKey] = changeObj[plotlyKey][traceInd].push(self.data[key][self.orderedIndicies[rowInd]]) - 1;%%00010                            });%%00010                        }%%00010                    });%%00010                    count++;%%00010%%00010                });%%00010            });%%00010%%00010        } else {%%00010%%00010            this.data.rowKeys.forEach(function (rowId, rowInd) {%%00010                var rowObj = self.rowDirectory[rowId];%%00010                rowObj.tInds.forEach(function (tInd) {%%00010                    if ((self.showOnlySelected &amp;&amp; !self.selected.has(rowId)) || !self.filtered.has(rowId)) {%%00010                        self.traceDirectory[tInd][rowId] = -1;%%00010                        return;%%00010                    }%%00010                    if (self.traceDirectory[tInd].dataKeys) {%%00010                        self.traceDirectory[tInd].dataKeys.forEach(function (key, keyInd) {%%00010                            if (key) {%%00010                                changeKeys[keyInd].forEach(function (plotlyKey) {%%00010                                    var newPID = changeObj[plotlyKey][tInd].push(self.data[key][rowObj.pInd]) - 1;%%00010                                    self.traceDirectory[tInd][rowId] = newPID;%%00010                                });%%00010                            } else {%%00010                                changeKeys[keyInd].forEach(function (plotlyKey) {%%00010                                    changeObj[plotlyKey][tInd] = null;%%00010                                });%%00010                            }%%00010                        });%%00010                    }%%00010                });%%00010            });%%00010        }%%00010%%00010        if (this.isSurface) {%%00010            changeObj.z = [changeObj.z];%%00010        } else {%%00010            changeObj.selectedpoints = this.getSelectedPoints();%%00010        }%%00010        return changeObj;%%00010    };%%00010%%00010    /**%%00010     * This method handles the actual invocation of updating the parent chart.%%00010     * It optionally takes in three parameters. If only a changeObj is passed in%%00010     * it will call the Plotly.restyle() method (which has the least overhead to %%00010     * update a chart's data). Alternatively, if a changeObj is not passed in, and the%%00010     * onlyLayout option is *not* set to true, then the method will go and get%%00010     * the most updated data to update the chart. If a layoutObj is passed in%%00010     * either Plotly.relayout() (most efficient way to update chart layout) or%%00010     * the Plotly.update() (most efficient way to update both layout and data).%%00010     * %%00010     * @param  {Object || null} inChangeObj the changeObj to be passed to Plotly%%00010     * @param  {Object || null} layoutObj the layoutObj %%00010     * @param  {boolean || null} onlyLayout true if update only the layout%%00010     */%%00010    KnimePlotlyInterface.update = function (inChangeObj, layoutObj, onlyLayout) {%%00010        if (onlyLayout &amp;&amp; layoutObj) {%%00010            this.Plotly.relayout(this.divID, layoutObj);%%00010        } else {%%00010            var changeObj = inChangeObj || this.getFilteredChangeObject();%%00010            layoutObj = this.updateTicks(changeObj, layoutObj);%%00010            if (layoutObj) {%%00010                this.Plotly.update(this.divID, changeObj, layoutObj);%%00010            } else {%%00010                this.Plotly.restyle(this.divID, changeObj);%%00010            }%%00010        }%%00010    };%%00010%%00010    /**%%00010     * This method can be used to set or update the keys which are returned%%00010     * each time a new changeObj is created. It's also possible to set trace-%%00010     * specific keys for different scenarios, such as when different traces%%00010     * have different data or have different Plotly keys. The keys passed in%%00010     * should be valid Plotly configuration option keys (ex: x, y, marker, etc.)%%00010     * %%00010     * @param  {Object} keys object%%00010     *          *EITHER*%%00010     * @param  {Object} keys.plotlyKeys the data-bound key literals%%00010     *      which need to be updated in the changeObj each time there is a data%%00010     *      update%%00010     *          *OR*%%00010     * @param  {Object} keys.dataKeys the array of arrays containing trace-%%00010     *      specific keys%%00010     */%%00010    KnimePlotlyInterface.updateKeys = function (keys) {%%00010        var self = this;%%00010        if (keys.plotlyKeys) {%%00010            this.changeObjKeys = keys.plotlyKeys;%%00010        }%%00010%%00010        if (keys.dataKeys &amp;&amp; self.traceDirectory) {%%00010            keys.dataKeys.forEach(function (key, keyInd) {%%00010                if (key) {%%00010                    if (key.length &amp;&amp; Array.isArray(key)) {%%00010                        key.forEach(function (tKey, tInd) {%%00010                            self.traceDirectory[tInd].dataKeys[keyInd] = tKey;%%00010                        });%%00010                    } else {%%00010                        self.traceDirectory.forEach(function (trace) {%%00010                            if (trace.dataKeys[keyInd]) {%%00010                                trace.dataKeys[keyInd] = key;%%00010                            }%%00010                        });%%00010                    }%%00010                }%%00010            });%%00010        }%%00010    };%%00010%%00010    /**%%00010     * This method is used both internally and externally (by%%00010     * the parent chart) to update the view value which should%%00010     * be stored inside the KPI instance. The object passed%%00010     * as a parameter can have one of more keys and each key %%00010     * will be mapped to the ViewValue.%%00010     * %%00010     * @param  {Object} newValue.foo the object with ViewValue%%00010     *      fields and their associated values to be set%%00010     */%%00010    KnimePlotlyInterface.updateValue = function (newValue) {%%00010        for (var key in newValue) {%%00010            this.value.options[key] = newValue[key];%%00010        }%%00010    };%%00010%%00010    /**%%00010     * This method is consumes both Knime-published event objects%%00010     * and Plotly event objects. It clears the internal field%%00010     * this.selected and creates a new KSet containing all of the%%00010     * rowKeys that are currently selected.%%00010     * %%00010     * If the event comes from a Plotly publisher, then the logic %%00010     * uses multiple steps to find the id from the actual DOM %%00010     * elements which were selected, usually through the trace%%00010     * ids, but sometimes through the point indicies in the TraceMaps.%%00010     * When the event is a Plotly event, the method also checks to see%%00010     * if there are other views available in the window scope and %%00010     * publishes the rowIds of the selected points for other Knime%%00010     * views.%%00010     * %%00010     * If the event is published by the KnimeService (i.e. incomming)%%00010     * then this method will set the internal .selected field to%%00010     * whatever the incomming selection set is.%%00010     * %%00010     * This method also contains the logic which allows the violin plot%%00010     * to show all points on load, but also react as if showOnlySelected%%00010     * was enabled when it is in a composite view by hard-coded default%%00010     * (implemented per request from Data Scientists).%%00010     * %%00010     * Lastly, this method will update the ViewValue .selected field so%%00010     * the rowIds are available if the node is closed, or the settings %%00010     * are applied.%%00010     * %%00010     * @param  {Object} data either the Plotly or Knime selection event%%00010     *      object%%00010     */%%00010    KnimePlotlyInterface.updateSelected = function (data) {%%00010        var self = this;%%00010%%00010        if (!data) {%%00010            return;%%00010        }%%00010%%00010        this.selected = new this.KSet([]);%%00010        this.totalSelected = 0;%%00010%%00010        if (data.points) { // this is for Plotly events%%00010%%00010            if (data.range &amp;&amp; ((data.range.x2 || data.range.y2) || (data.points.length &amp;&amp;%%00010                data.points[0] &amp;&amp; data.points[0].r))) {%%00010                // if ((data.range &amp;&amp; (data.range.x2 || data.range.y2))) {%%00010                data.points.forEach(function (pt) {%%00010                    var ptRowKeys = pt.fullData.ids;%%00010                    var ptInds = pt.pointIndices || [pt.pointIndex];%%00010                    ptInds.forEach(function (ptInd) {%%00010                        var rowKey = ptRowKeys[ptInd];%%00010                        self.selected.add(rowKey);%%00010                        self.totalSelected++;%%00010                    });%%00010                });%%00010            } else {%%00010                data.points.forEach(function (pt) {%%00010                    self.selected.add(pt.id);%%00010                    self.totalSelected++;%%00010                });%%00010            }%%00010%%00010            if (self.value.options.publishSelection &amp;&amp; knimeService.getGlobalService()) {%%00010                knimeService.setSelectedRows(%%00010                    this.table.getTableId(),%%00010                    this.selected.getArray(),%%00010                    this.onSelectionChange%%00010                );%%00010            }%%00010%%00010        } else { // this is for incoming knime events%%00010            this.selected = new this.KSet([]);%%00010            var incomingSelected = knimeService.getAllRowsForSelection(%%00010                this.table.getTableId()%%00010            );%%00010            if (incomingSelected.length &gt; 0) {%%00010                this.totalSelected = 1;%%00010            }%%00010            incomingSelected.forEach(function (rowKey) {%%00010                if (typeof self.rowDirectory[rowKey] !== 'undefined') {%%00010                    self.selected.add(rowKey);%%00010                    self.totalSelected++;%%00010                }%%00010            });%%00010        }%%00010%%00010        if (self.totalSelected === 0 &amp;&amp;%%00010            self.showOnlySelected &amp;&amp;%%00010            self.onlySelectedBehavior === 'violin') {%%00010            self.showOnlySelected = false;%%00010            self.lastSOSState = true;%%00010        } else if (self.totalSelected &gt; 0 &amp;&amp;%%00010            self.lastSOSState &amp;&amp;%%00010            self.onlySelectedBehavior === 'violin') {%%00010            self.showOnlySelected = true;%%00010        }%%00010%%00010        this.updateValue({ selectedrows: self.selected.getArray() });%%00010    };%%00010%%00010    /**%%00010     * This method takes in a KnimeService-published filter event object%%00010     * and updates the internal KPI.filtered field with a new KSet containing%%00010     * the rowKeys of the rows that are included in the chart *after* the %%00010     * filter has been applied. This method *should* support both numeric%%00010     * and nominal filters as well as multiple filters across different %%00010     * columns.%%00010     * %%00010     * @param  {Object} data the KnimeService filter object%%00010     * @param  {array} data.elements an array of filter elements%%00010     * @param  {Object} data.elements[i].type the type of the filter (only %%00010     *      &quot;range&quot; is currently supported by KnimeService)%%00010     * @param  {array} data.elements[i].columns an array of column filter%%00010     *      object%%00010     * @param  {Object} data.elements[i].columns[i] actual filter with keys%%00010     *      for [type] = &quot;numeric&quot;: [minimumInclusive] || [maximumInclusive],%%00010     *       [minimum{number}], [maximum{number}] *OR* for [type] = &quot;nominal&quot; :%%00010     *       [values{array}]%%00010     *      %%00010     */%%00010    KnimePlotlyInterface.updateFilter = function (data) {%%00010%%00010        if (!data || !data.elements) {%%00010            return;%%00010        }%%00010%%00010        var self = this;%%00010%%00010        this.filtered = new this.KSet([]);%%00010%%00010        data.elements.forEach(function (filterElement, filterInd) {%%00010            if (filterElement.type === 'range' &amp;&amp; filterElement.columns) {%%00010                for (var col = 0; col &lt; filterElement.columns.length; col++) {%%00010                    var column = filterElement.columns[col];%%00010                    self.data[column.columnName].forEach(function (colVal, colInd) {%%00010                        if (typeof colVal === 'undefined' || colVal === null) {%%00010                            return;%%00010                        }%%00010                        var included = true;%%00010                        var rKey = self.data.rowKeys[colInd];%%00010                        if (column.type === 'numeric') {%%00010                            if (column.minimumInclusive) {%%00010                                included = included &amp;&amp; colVal &gt;= column.minimum;%%00010                            } else {%%00010                                included = included &amp;&amp; colVal &gt; column.minimum;%%00010                            }%%00010                            if (column.maximumInclusive) {%%00010                                included = included &amp;&amp; colVal &lt;= column.maximum;%%00010                            } else {%%00010                                included = included &amp;&amp; colVal &lt; column.maximum;%%00010                            }%%00010                        } else if (column.type === 'nominal') {%%00010                            included = included &amp;&amp; column.values.indexOf(colVal) &gt;= 0;%%00010                        }%%00010                        if (included) {%%00010                            if (filterInd &gt; 0 &amp;&amp; !self.filtered.has(rKey)) {%%00010                                return;%%00010                            }%%00010                            self.filtered.add(rKey);%%00010                        } else if (self.filtered.has(rKey)) {%%00010                            self.filtered.delete(rKey);%%00010                        }%%00010                    });%%00010                }%%00010            }%%00010        });%%00010    };%%00010%%00010    /**%%00010     * This method creates and updates the interally sorted indicies used when %%00010     * providing data in Plotly change objects. If a chart require ordered data%%00010     * (such as the line chart), this method will take a parameter (String) for%%00010     * the column name that is to be the ordered axis (usually the x-axis). It %%00010     * will then parse for Data/Time values and, if necessary, convert them to %%00010     * Unix millisecond timestamps to allow them to be sorted as numbers. This%%00010     * method then uses and internal implementation of Merge Sort to create%%00010     * an array of original indicies in the correct order. This array is then%%00010     * set as the internal state of order for the KPI instance and is used%%00010     * whenever new data or data updates are required for the Plot. %%00010     * %%00010     * In the view when features are updated (such as user choosing new x-axis)%%00010     * this method will be called again and the internal order updated.%%00010     * %%00010     * @param  {String} newOrderedColumnName name of the column to order by%%00010     */%%00010    KnimePlotlyInterface.updateOrderedIndicies = function (newOrderedColumnName) {%%00010        var self = this;%%00010        this.isOrdered = true;%%00010        var array = self.data[newOrderedColumnName];%%00010        if (typeof array[0] === 'string') {%%00010            if (array[0].indexOf('Row') !== -1) {%%00010                var failedParse = false;%%00010                array = array.map(function (rowId) {%%00010                    var rowNum = parseFloat(rowId.split('Row')[1]);%%00010                    if (isNaN(rowNum)) {%%00010                        failedParse = true;%%00010                    }%%00010                    return rowNum;%%00010                });%%00010                if (failedParse) {%%00010                    self.orderedIndicies = array.map(function (e, i) { return i; });%%00010                    return;%%00010                }%%00010            } else if (this.table.getColumnTypes()[this.columns.indexOf(newOrderedColumnName)] ===%%00010                'dateTime' &amp;&amp; this.representation.options.hasDateTime) {%%00010                if (this.moment(array[0].isValid())) {%%00010                    array = array.map(function (date) {%%00010                        return self.moment(date).valueOf();%%00010                    });%%00010                }%%00010            } else {%%00010                self.orderedIndicies = array.map(function (e, i) { return i; });%%00010                return;%%00010            }%%00010        }%%00010        var indicies = [];%%00010%%00010        for (var i = 0; i &lt; array.length; i++) {%%00010            indicies.push(i);%%00010        }%%00010%%00010        var merge = function (lArr, rArr) {%%00010            var sortedArr = [];%%00010            var sortedInd = [];%%00010            var lInd = 0;%%00010            var rInd = 0;%%00010%%00010            while (lInd &lt; lArr[0].length &amp;&amp; rInd &lt; rArr[0].length) {%%00010                if (lArr[0][lInd] &lt; rArr[0][rInd]) {%%00010                    sortedArr.push(lArr[0][lInd]);%%00010                    sortedInd.push(lArr[1][lInd]);%%00010                    lInd++;%%00010                } else {%%00010                    sortedArr.push(rArr[0][rInd]);%%00010                    sortedInd.push(rArr[1][rInd]);%%00010                    rInd++;%%00010                }%%00010            }%%00010%%00010            return [sortedArr.concat(lArr[0].slice(lInd)).concat(rArr[0].slice(rInd)),%%00010            sortedInd.concat(lArr[1].slice(lInd)).concat(rArr[1].slice(rInd))];%%00010        };%%00010%%00010        var mergeSort = function (subArr, indArr) {%%00010            if (subArr.length &lt;= 1) {%%00010                return [subArr, indArr];%%00010            }%%00010%%00010            var centInd = Math.floor(subArr.length / 2);%%00010            var leftArr = subArr.slice(0, centInd);%%00010            var rightArr = subArr.slice(centInd);%%00010            var lIndArr = indArr.slice(0, centInd);%%00010            var rIndArr = indArr.slice(centInd);%%00010%%00010            var lSortArr = mergeSort(leftArr, lIndArr);%%00010            var rSortArr = mergeSort(rightArr, rIndArr);%%00010            return merge(lSortArr, rSortArr);%%00010        };%%00010%%00010        var xYz = mergeSort(array, indicies);%%00010        self.orderedIndicies = xYz[1];%%00010    };%%00010%%00010    /**%%00010     * Utility method to resort an array of data based on the internal%%00010     * ordering state. This is used for any sort of plot that requires%%00010     * data to be contiguous (such as line based plots) and is called%%00010     * by the getFilteredChangeObject method and the getData method.%%00010     * It can later be &quot;privatised&quot; by making it a local variable, as%%00010     * it is not yet used in any charts directly.%%00010     * %%00010     * @param  {array} array containing values to order%%00010     * @returns {array} an array containing the ordered data%%00010     */%%00010    KnimePlotlyInterface.getOrderedArray = function (array) {%%00010        var orderedData = [];%%00010%%00010        for (var i = 0; i &lt; array.length; i++) {%%00010            orderedData[i] = array[this.orderedIndicies[i]];%%00010        }%%00010%%00010        return orderedData.filter(function (val) { return val === 0 || val; });%%00010    };%%00010%%00010    /**%%00010     * This method is exposed for charts to call when the showOnlySelected %%00010     * button is clicked by the user. It updates the internal state of the%%00010     * KPI instance, which affects the included data in selection and filter%%00010     * methods.%%00010     * %%00010     * @param  {boolean} bool the state of showOnlySelected internally%%00010     */%%00010    KnimePlotlyInterface.updateShowOnlySelected = function (bool) {%%00010        this.showOnlySelected = bool;%%00010    };%%00010%%00010    /**%%00010     * This general initialization function should be called by the plot itself;%%00010     * passing in the two required callback functions. The correct place to call%%00010     * this method in the lifecycle of a Plotly .js view is after the drawChart%%00010     * method is invoked. In addition to providing KnimeService with the required%%00010     * callback functions it needs for interactive events, this method also triggers%%00010     * a title spacing call (adjustTitleSpacing) and a call to remove any extra%%00010     * axis labels (removeSecondAxisLabels). *Critically* it also handles the mounting%%00010     * of event listeners for each of the Plotly-published events: plotly_relayout,%%00010     * plotly_restyle, plotly_selected &amp; plotly_deselect.%%00010     * %%00010     * @param  {Function} selectionChange the callback function to handle selection%%00010     *      changes either from the KnimeService or internally%%00010     * @param  {} filterChange filterChange the callback function to handle filter%%00010     *      changes from the KnimeService%%00010     */%%00010    KnimePlotlyInterface.mountAndSubscribe = function (selectionChange, filterChange) {%%00010        var self = this;%%00010        var hasSecondAxis = this.removeSecondAxisElements();%%00010        this.adjustTitleSpacing();%%00010%%00010        document.getElementById(this.divID).on('plotly_relayout', function (eData) {%%00010            if (eData) {%%00010                if (hasSecondAxis) {%%00010                    self.removeSecondAxisElements();%%00010                }%%00010                var valueObj = {};%%00010                if (eData['xaxis.title.text']) {%%00010                    valueObj.xAxisLabel = eData['xaxis.title.text'];%%00010                }%%00010                if (eData['yaxis.title.text']) {%%00010                    valueObj.yAxisLabel = eData['yaxis.title.text'];%%00010                }%%00010                if (eData['title.text']) {%%00010                    valueObj.title = eData['title.text'];%%00010                }%%00010                self.updateValue(valueObj);%%00010            }%%00010            self.adjustTitleSpacing();%%00010        });%%00010        document.getElementById(this.divID).on('plotly_restyle', function (plotlyEvent) {%%00010            if (plotlyEvent &amp;&amp; plotlyEvent.length) {%%00010                if (plotlyEvent[0] &amp;&amp; plotlyEvent[0].colorscale &amp;&amp; plotlyEvent[0].colorscale.length) {%%00010                    var valueObj = { colorscale: plotlyEvent[0].colorscale[0] };%%00010                    self.updateValue(valueObj);%%00010                }%%00010            }%%00010            self.adjustTitleSpacing();%%00010        });%%00010        document.getElementById(this.divID).on('plotly_selected', function (plotlyEvent) {%%00010            selectionChange(plotlyEvent);%%00010            self.adjustTitleSpacing();%%00010        });%%00010        document.getElementById(this.divID).on('plotly_deselect', function () {%%00010            selectionChange({ points: [] });%%00010            self.adjustTitleSpacing();%%00010        });%%00010%%00010        this.togglePublishSelection();%%00010        this.toggleSubscribeToFilters(filterChange);%%00010        this.toggleSubscribeToSelection(selectionChange);%%00010    };%%00010%%00010    /**%%00010     * This method is used to rotate y-axis labels 90 degrees when they are String values%%00010     * (such as when dislaying grouped charts) or to set the angle for Numeric values%%00010     * which tend to run off the screen when they are very long. It is called during the%%00010     * drawing of the chart as well as during subsequent &quot;update&quot; calls, if there is a%%00010     * layoutObj provided.%%00010     * %%00010     * @param  {Object} changeObj the KPI changeObj involved in the Plotly update event%%00010     * @param  {array} changeObj.y the array containing (n*numTraces)*[y1,y2,...] values%%00010     * @param  {array} changeObj.y[i] the array containing the y values for a single trace%%00010     * @param  {Object} layoutObj the KPI layoutObj involved in the Plotly update event%%00010     * @param  {Object || null} layoutObj.yaxis this key containing the object holding the%%00010     *      y-axis configuration options. If layoutObj.yaxis is missing, then it will be %%00010     *      dynamically created and the &quot;tickangle&quot; property will be set to the appropriate%%00010     *      value based on the y &quot;type&quot;%%00010     *  %%00010     * @returns {Object} layoutObj the updated KPI layoutObj with the correct tick angles%%00010     */%%00010    KnimePlotlyInterface.updateTicks = function (changeObj, layout) {%%00010        var layoutObj = layout;%%00010        if (changeObj.y &amp;&amp; changeObj.y.length &gt; 0 &amp;&amp;%%00010            changeObj.y[0] &amp;&amp; changeObj.y[0].length) {%%00010            if (typeof changeObj.y[0][0] === 'string') {%%00010                layoutObj = layoutObj || {};%%00010                if (layoutObj.yaxis) {%%00010                    layoutObj.yaxis.tickangle = -90;%%00010                } else {%%00010                    layoutObj['yaxis.tickangle'] = -90;%%00010                }%%00010                this.rotatedTicks = true;%%00010            } else if (this.rotatedTicks &amp;&amp; typeof changeObj.y[0][0] === 'number') {%%00010                layoutObj = layoutObj || {};%%00010                if (layoutObj.yaxis) {%%00010                    layoutObj.yaxis.tickangle = -0;%%00010                } else {%%00010                    layoutObj['yaxis.tickangle'] = -0;%%00010                }%%00010                this.rotatedTicks = true;%%00010            }%%00010        }%%00010        return layoutObj;%%00010    };%%00010%%00010    /**%%00010     * This method solves a bug with Plotly where sometimes the main chart%%00010     * title is overlapping or inaccurately placed on the chart. This method%%00010     * is called during the MountAndSubscribe method and during subsequent%%00010     * Plotly &quot;relayout&quot; events. It changes the html tags to re-align the %%00010     * title.%%00010     */%%00010    KnimePlotlyInterface.adjustTitleSpacing = function () {%%00010        if (document.querySelector('.gtitle')) {%%00010            document.querySelector('.gtitle').setAttribute('dy', '-.5em');%%00010        }%%00010    };%%00010%%00010    /**%%00010     * This method is used to remove unwanted axis labels from secondary%%00010     * axis, such as in the 2D Density plot when Histograms are enabled.%%00010     * We decided jointly that being able to edit multiple axis labels %%00010     * (2+ for x, 2+ for y) was unwanted behavior, so this method removes%%00010     * them manually and is called by MountAndSubscribe upon graph init-%%00010     * ializaion and during subsequent Plotly &quot;relayout&quot; events. %%00010     * %%00010     * @returns {boolean} true if multiple axis labels were removed and%%00010     *      false if there were no 2nd axis in the DOM%%00010     */%%00010    KnimePlotlyInterface.removeSecondAxisElements = function () {%%00010        var x2Title = document.querySelector('.x2title');%%00010        var y2Title = document.querySelector('.y2title');%%00010        if (x2Title &amp;&amp; y2Title) {%%00010            x2Title.remove();%%00010            y2Title.remove();%%00010            return true;%%00010        } else {%%00010            return false;%%00010        }%%00010    };%%00010%%00010    /**%%00010     * This method takes a callback function as a parameter to be called by the KnimeService%%00010     * everytime there is a filter change. It is called internally by the MountAndSubscribe%%00010     * method, through which these custom callback functions should be passed by the views%%00010     * themselves. It is important to bind lexical &quot;this&quot; to the callbacks.%%00010     * %%00010     * @param  {Function} onFilterChange the function to call when filter events are published%%00010     */%%00010    KnimePlotlyInterface.toggleSubscribeToFilters = function (onFilterChange) {%%00010        if (this.value.options.subscribeToFilters) {%%00010            knimeService.subscribeToFilter(%%00010                this.table.getTableId(),%%00010                onFilterChange,%%00010                this.table.getFilterIds()%%00010            );%%00010        } else {%%00010            knimeService.unsubscribeFilter(%%00010                this.table.getTableId(),%%00010                onFilterChange%%00010            );%%00010        }%%00010    };%%00010%%00010    /**%%00010     * This method takes a callback function as a parameter to be called by the KnimeService%%00010     * everytime there is a selection change. It is called internally by the MountAndSubscribe%%00010     * method, through which these custom callback functions should be passed by the views%%00010     * themselves. It is important to bind lexical &quot;this&quot; to the callbacks.%%00010     * %%00010     * @param  {Function} onSelectionChange the function to call when selection changes%%00010     */%%00010    KnimePlotlyInterface.toggleSubscribeToSelection = function (onSelectionChange) {%%00010        if (this.value.options.subscribeToSelection) {%%00010            knimeService.subscribeToSelection(%%00010                this.table.getTableId(),%%00010                onSelectionChange%%00010            );%%00010        } else {%%00010            knimeService.unsubscribeSelection(%%00010                this.table.getTableId(),%%00010                onSelectionChange%%00010            );%%00010        }%%00010    };%%00010%%00010    /**%%00010     * This method will toggle on and off the publishing functionality%%00010     * of the plot. When it is toggled off, it does *not* publish any-%%00010     * thing; rather leaves the composite view selection state as-is.%%00010     * When toggled on, it publishes the current selection from the %%00010     * Plotly view to other views in the same interactivity scope.%%00010     */%%00010    KnimePlotlyInterface.togglePublishSelection = function () {%%00010        if (this.value.options.publishSelection) {%%00010            knimeService.setSelectedRows(%%00010                this.table.getTableId(),%%00010                this.selected.getArray()%%00010            );%%00010        }%%00010    };%%00010%%00010    /**%%00010     * Utility function to create a basic index mapping of%%00010     * rowIds to their initial indicies. These indicies will%%00010     * be used as a direct pointer reference to the row in various%%00010     * methods such as filtering, selection, etc. This method should%%00010     * be called with the &quot;new&quot; initialization keyword, as it creates%%00010     * a literal JavaScript object in the format {rowKey_0: 1, ...}.%%00010     * %%00010     * These indicies are later updated as the data points realtime %%00010     * location *within* the Plotly traces. &quot;i&quot; represents the initial %%00010     * index of the data within each trace, but as traces are modified,%%00010     * the value is updated to reflect their current position (with -1%%00010     * being used to represent absent or &quot;missing&quot;). These indicies are%%00010     * mapped to the rowIds to provide a non-iterative reference pointer%%00010     * for quick view manipulation.%%00010     * %%00010     * @param  {} traceIds%%00010     */%%00010    KnimePlotlyInterface.TraceMap = function (traceIds) {%%00010        for (var i = 0; i &lt; traceIds.length; i++) {%%00010            this[traceIds[i]] = i;%%00010        }%%00010    };%%00010%%00010    /**%%00010     * Utility class/polyfill to create a functionally equivalent%%00010     * ES5 compliant version of a JavaScript Map. Should be %%00010     * initialized with the &quot;new&quot; keyword. See internal method%%00010     * documentation for other functionality. Offers the added%%00010     * benefits (over just using JavaScript Object mapping) that%%00010     * you can retrieve keys and values with methods, where IE11%%00010     * sometimes complains about the JS native methods.%%00010     * %%00010     * @param  {array} iterable to initialize the map in the format%%00010     *      expected : [[foo, bar], ....]%%00010     */%%00010    KnimePlotlyInterface.KMap = function (iterable) {%%00010%%00010        var obj = {};%%00010        var keys = [];%%00010        var values = [];%%00010        var size = 0;%%00010%%00010        if (iterable &amp;&amp; iterable.length) {%%00010            for (var i = 0; i &lt; iterable.length; i++) {%%00010                if (typeof iterable[i][0] !== 'undefined') {%%00010                    this.set(iterable[i][0], iterable[i][1]);%%00010                    size++;%%00010                }%%00010            }%%00010        }%%00010%%00010        /**%%00010         * Utility method to add or update members of the map.%%00010         * %%00010         * @param  {Object} key the key to set%%00010         * @param  {Object} value the value to set%%00010         * @returns {KMap} this%%00010         */%%00010        this.set = function (key, value) {%%00010            if (this.has(key)) {%%00010                obj[key].value = value;%%00010            } else {%%00010                var ind = keys.push(key);%%00010                values.push(value);%%00010                obj[key] = {%%00010                    value: value,%%00010                    ind: ind%%00010                };%%00010                size++;%%00010            }%%00010            return this;%%00010        };%%00010%%00010        /**%%00010         * Utility method to check if a key exists in the map.%%00010         * %%00010         * @param  {Object} key the element to check for membership%%00010         * @returns {boolean} true if the parameter is a member, false%%00010         *      if the parameter is not a member%%00010         */%%00010        this.has = function (key) {%%00010            if (typeof obj[key] === 'undefined') {%%00010                return false;%%00010            } else {%%00010                return true;%%00010            }%%00010        };%%00010%%00010        /**%%00010         * Utility method to clear the map back to an empty state.%%00010         * %%00010         * @returns {KMap} this%%00010         */%%00010        this.clear = function () {%%00010            obj = {};%%00010            keys = [];%%00010            values = [];%%00010            size = 0;%%00010            return this;%%00010        };%%00010%%00010        /**%%00010         * Utility method to get the value mapped to the provided key.%%00010         * %%00010         * @param  {Object} key%%00010         * @returns {Object} value the value mapped to the key%%00010         */%%00010        this.get = function (key) {%%00010            return obj[key].value;%%00010        };%%00010%%00010        /**%%00010         * Utility method to delete the key-pair of the key provided.%%00010         * %%00010         * @param  {Object} key to delete%%00010         * @returns {boolean} true if the key was a member and was deleted,%%00010         *      false if the key was not a member%%00010         */%%00010        this.delete = function (key) {%%00010            if (typeof obj[key] === 'undefined') {%%00010                return false;%%00010            } else {%%00010                keys.splice(obj[key].ind, 1, null);%%00010                values.splice(obj[key].ind, 1, null);%%00010                delete this.obj[key];%%00010                size--;%%00010                return true;%%00010            }%%00010        };%%00010%%00010        /**%%00010         * Utility method to get an array of key-value pairs of all of the%%00010         * members in the map.%%00010         * %%00010         * @returns {array} an array of key-value pairs in the format: %%00010         *      [[foo, bar], ...]%%00010         */%%00010        this.entries = function () {%%00010            var result = [];%%00010            for (var i = 0; i &lt; values.length; i++) {%%00010                if (keys[i]) {%%00010                    result.push([keys[i], values[i]]);%%00010                }%%00010            }%%00010        };%%00010%%00010        /**%%00010         * Utility method to get all of the keys in the map.%%00010         * %%00010         * @returns {array} an array of all of the keys in the map%%00010         */%%00010        this.keys = function () {%%00010            return keys.filter(function (key) { return key; });%%00010        };%%00010%%00010        /**%%00010         * Utility method to get all of the values in the map.%%00010         * %%00010         * @returns {array} an array of all of the values in the map%%00010         */%%00010        this.values = function () {%%00010            return values.filter(function (val) { return val; });%%00010        };%%00010%%00010        /**%%00010         * Utility method to get the number of key-value pairs in the%%00010         * map.%%00010         * %%00010         * @returns {number} the number of key-value pairs in the map%%00010         */%%00010        this.size = function () {%%00010            return size;%%00010        };%%00010    };%%00010%%00010    /**%%00010     * Utility class/polyfill to create a functionally equivalent%%00010     * ES5 compliant version of a JavaScript Set. Should be %%00010     * initialized with the &quot;new&quot; keyword. See internal method%%00010     * documentation for other functionality.%%00010     * %%00010     * @param  {array} iterable%%00010     */%%00010    KnimePlotlyInterface.KSet = function (iterable) {%%00010%%00010        var data = {};%%00010        var size = 0;%%00010%%00010        if (iterable &amp;&amp; iterable.length) {%%00010            for (var i = 0; i &lt; iterable.length; i++) {%%00010                data[iterable[i]] = true;%%00010            }%%00010        }%%00010%%00010        /**%%00010         * Utility method to add member to the set.%%00010         * %%00010         * @param  {Object} member to be added to the set%%00010         * @returns {KSet} this%%00010         */%%00010        this.add = function (member) {%%00010            if (typeof member !== 'undefined') {%%00010                if (!this.has(member)) {%%00010                    size++;%%00010                }%%00010                data[member] = true;%%00010            }%%00010            return this;%%00010        };%%00010%%00010        /**%%00010         * Utility method to add multiple members to the set%%00010         * at one time.%%00010         * %%00010         * @param  {array} member to be added to the set%%00010         * @returns {KSet} this%%00010         */%%00010        this.addAll = function (members) {%%00010            if (members &amp;&amp; members.length) {%%00010                for (var i = 0; i &lt; members.length; i++) {%%00010                    if (typeof members[i] !== 'undefined') {%%00010                        data[members[i]] = true;%%00010                        size++;%%00010                    }%%00010                }%%00010            }%%00010            return this;%%00010        };%%00010%%00010        /**%%00010         * Utility method to check membership of an element.%%00010         * %%00010         * @param  {Object} element to check membership%%00010         * @returns {boolean} is the parameter a member of%%00010         *      this set%%00010         */%%00010        this.has = function (member) {%%00010            if (data[member] === true) {%%00010                return true;%%00010            } else {%%00010                return false;%%00010            }%%00010        };%%00010%%00010        /**%%00010         * Utility method to remove an member from the set.%%00010         * %%00010         * @param  {Object} member to remove from the set.%%00010         * @return {KSet} this%%00010         */%%00010        this.delete = function (member) {%%00010            if (this.has(member)) {%%00010                data[member] = false;%%00010                delete data[member];%%00010                size--;%%00010            }%%00010            return this;%%00010        };%%00010%%00010        /**%%00010         * Utility method to clear the set of all members.%%00010         * %%00010         * @returns {KSet} this%%00010         */%%00010        this.clear = function () {%%00010            data = {};%%00010            size = 0;%%00010            return this;%%00010        };%%00010%%00010        /**%%00010         * Utility method to get the number of members that%%00010         * are in the set. %%00010         * %%00010         * @return {number} the size of the set%%00010         */%%00010        this.size = function () {%%00010            return size;%%00010        };%%00010%%00010        /**%%00010         * Utility method to convert the set into an array and%%00010         * return that array.%%00010         * %%00010         * @returns {array} the array of object members in%%00010         *      insertion order.%%00010         */%%00010        this.getArray = function () {%%00010            var setArray = [];%%00010            for (var key in data) {%%00010                if (key) {%%00010                    setArray.push(key);%%00010                }%%00010            }%%00010            return setArray;%%00010        };%%00010    };%%00010%%00010    /**%%00010     * Utility method to convert hex color strings in the format '#ffffff'%%00010     * to RGBA format strings in the format 'rgba(rrr,ggg,bbb,a)'. Ommitting%%00010     * the Alpha value for the color will default the value to 1, or 100%%%00010     * opaque.%%00010     * %%00010     * @param  {string} hColor the hex format color string to convert to %%00010     *      RGBA format%%00010     * @param  {number (double -&gt; [0,1])} alph alpha value between 0-1 for%%00010     *      the opacity of the returned RGBA string%%00010     * @returns {string} rgba format string of the input hex color%%00010     */%%00010    KnimePlotlyInterface.hexToRGBA = function (hColor, alph) {%%00010        if (!alph) {%%00010            alph = 1;%%00010        }%%00010        return 'rgba(' + parseInt(hColor.slice(1, 3), 16) + ', ' +%%00010            parseInt(hColor.slice(3, 5), 16) + ', ' +%%00010            parseInt(hColor.slice(5, 7), 16) + ', ' + alph + ')';%%00010    };%%00010%%00010    /**%%00010     * Utility method to get the names of all of the numeric columns%%00010     * contained within the internally held KPI table.%%00010     * %%00010     * @returns {['Universe_0', ...]} an array of the numeric column names%%00010     */%%00010    KnimePlotlyInterface.getNumericColumns = function () {%%00010        var columns = this.table.getColumnNames();%%00010        var columnTypes = this.table.getColumnTypes();%%00010        var numColumns = columns.filter(function (c, i) {%%00010            return columnTypes[i] === 'number';%%00010        });%%00010        return numColumns;%%00010    };%%00010%%00010    /**%%00010     * Utility method to return the possible column types by checking the %%00010     * types of the columns in the KPI table spec. It also takes a parameter%%00010     * for if the &quot;rowKeys&quot; type should be included. This method does return %%00010     * Date/Time types (hence the &quot;...W...&quot; in the name).%%00010     * %%00010     * @param  {boolean} inclRowKey true if the 'rowKeys' column type should%%00010     *      be included in the returned array%%00010     * @returns {['foo', ...]} an array of KNIME column types as strings%%00010     */%%00010    KnimePlotlyInterface.getXYCartesianColsWDate = function (inclRowKey) {%%00010        var columns = this.table.getColumnNames();%%00010        var columnTypes = this.table.getKnimeColumnTypes();%%00010        var xyCartColTypes = ['Number (integer)', 'Number (long)', 'Number (double)',%%00010            'Date and Time', 'String', 'Local Date', 'Local Time',%%00010            'Local Date Time', 'Zoned Date Time', 'Period', 'Duration'];%%00010        var inclCols = columns.filter(function (c, i) {%%00010            return xyCartColTypes.indexOf(columnTypes[i]) &gt; -1;%%00010        });%%00010        if (inclRowKey) {%%00010            inclCols.push('rowKeys');%%00010        }%%00010        return inclCols;%%00010    };%%00010%%00010    /**%%00010     * Utility method to return the possible column types by checking the %%00010     * types of the columns in the KPI table spec. It also takes a parameter%%00010     * for if the &quot;rowKeys&quot; type should be included. This method does NOT %%00010     * return Date/Time types (hence the &quot;...WO...&quot; in the name).%%00010     * %%00010     * @param  {boolean} inclRowKey true if the 'rowKeys' column type should%%00010     *      be included in the returned array%%00010     * @returns {['foo', ...]} an array of KNIME column types as strings%%00010     */%%00010    KnimePlotlyInterface.getXYCartesianColsWODate = function (inclRowKey) {%%00010        var columns = this.table.getColumnNames();%%00010        var columnTypes = this.table.getKnimeColumnTypes();%%00010        var xyCartColTypes = ['Number (integer)', 'Number (long)', 'Number (double)',%%00010            'String'];%%00010        var inclCols = columns.filter(function (c, i) {%%00010            return xyCartColTypes.indexOf(columnTypes[i]) &gt; -1;%%00010        });%%00010        if (inclRowKey) {%%00010            inclCols.push('rowKeys');%%00010        }%%00010        return inclCols;%%00010    };%%00010%%00010    /**%%00010     * This utility method returns the most requent color in an array%%00010     * of color strings. Technically, it will return the most common%%00010     * string member of any array, but in the KPI it is used to find%%00010     * the most common color in collections of data points.%%00010     * %%00010     * @param  {['foo', ...]} rowColors as hex strings ('#ffffff')%%00010     * @returns {string} most common color in the parameterized array%%00010     */%%00010    KnimePlotlyInterface.getMostFrequentColor = function (rowColors) {%%00010        return rowColors.sort(function (c1, c2) {%%00010            return rowColors.filter(function (c3) {%%00010                return c3 === c1;%%00010            }).length - rowColors.filter(function (c4) {%%00010                return c4 === c2;%%00010            });%%00010        }).pop();%%00010    };%%00010%%00010    /**%%00010     * Clears internally held JSONData rows after they have been pivoted%%00010     * from a row-wise format to a columnar storage format. Keeps the %%00010     * original table meta-info from the BufferedDataTable.%%00010     */%%00010    KnimePlotlyInterface.collectGarbage = function () {%%00010        this.representation.inObjects[0].rows = null;%%00010        this.table.setDataTable(this.representation.inObjects[0]);%%00010    };%%00010%%00010    return KnimePlotlyInterface;%%00010};%%00010"/>
<entry key="1" type="xstring" value="/* global kt:false, twinlistMultipleSelections:false, KnimePlotlyInterface:false */%%00010window.knimePlotlyLinePlot = (function () {%%00010%%00010    var LinePlot = {};%%00010%%00010    LinePlot.init = function (representation, value) {%%00010%%00010        this.KPI = new KnimePlotlyInterface();%%00010        this.KPI.initialize(representation, value, new kt(), arguments[2]);%%00010        this.columns = this.KPI.getXYCartesianColsWDate(true);%%00010        this.numericColumns = this.KPI.getNumericColumns();%%00010        this.xAxisCol = this.KPI.value.options.xAxisColumn || 'rowKeys';%%00010        this.lineColumns = this.KPI.value.options.columns || [];%%00010        this.onSelectionChange = this.onSelectionChange.bind(this);%%00010        this.onFilterChange = this.onFilterChange.bind(this);%%00010%%00010        this.drawChart();%%00010        this.drawKnimeMenu();%%00010        this.KPI.mountAndSubscribe(this.onSelectionChange, this.onFilterChange);%%00010    };%%00010%%00010    LinePlot.drawChart = function () {%%00010        var gridColor = this.KPI.hexToRGBA(this.KPI.representation.options.gridColor, .15);%%00010        var t = this.createTraces();%%00010        var l = new this.LayoutObject(this.KPI.representation, this.KPI.value, gridColor);%%00010        var c = new this.ConfigObject(this.KPI.representation, this.KPI.value);%%00010        this.KPI.createElement('knime-line');%%00010        this.KPI.drawChart(t, l, c);%%00010        this.KPI.update();%%00010    };%%00010%%00010    LinePlot.createTraces = function () {%%00010        var self = this;%%00010        var traces = [];%%00010        this.KPI.updateOrderedIndicies(this.xAxisCol);%%00010        var keys = {%%00010            dataKeys: [self.xAxisCol, 'rowKeys', 'rowColors'],%%00010            plotlyKeys: [['x'], ['text', 'ids'], ['marker.color']]%%00010        };%%00010        this.KPI.updateKeys(keys);%%00010        var data = self.KPI.getData(keys);%%00010%%00010        self.lineColumns.forEach(function (col, colInd) {%%00010            var yData = self.KPI.getData({ dataKeys: [col] });%%00010            var xData = data[self.xAxisCol][0];%%00010            var newTrace = new self.TraceObject(xData, yData[col][0]);%%00010%%00010            newTrace.marker.color = data.rowColors[0];%%00010            newTrace.text = data.rowKeys[0];%%00010            newTrace.ids = data.rowKeys[0];%%00010            newTrace.name = col;%%00010            newTrace.dataKeys = [self.xAxisCol, col, 'rowKeys', 'rowColors'];%%00010            traces.push(newTrace);%%00010        });%%00010%%00010        keys = {%%00010            plotlyKeys: [['x'], ['y'], ['text', 'ids'], ['marker.color']]%%00010        };%%00010        this.KPI.updateKeys(keys);%%00010        return traces;%%00010    };%%00010%%00010    LinePlot.TraceObject = function (xData, yData) {%%00010        this.x = xData;%%00010        this.y = yData;%%00010        this.mode = 'lines+markers';%%00010        this.type = 'scatter';%%00010        this.name = '';%%00010        this.marker = {%%00010            color: [],%%00010            opacity: .5,%%00010            size: 4%%00010            // line: {%%00010            //     width: 1%%00010            // }%%00010        };%%00010        this.line = {%%00010            color: [],%%00010            opacity: .1,%%00010            width: 1%%00010        };%%00010        this.unselected = {%%00010            marker: {%%00010                opacity: .1%%00010            }%%00010        };%%00010        this.selected = {%%00010            marker: {%%00010                opacity: 1,%%00010                size: 10,%%00010                line: {%%00010                    width: 10,%%00010                    color: '#ffffff'%%00010                }%%00010            }%%00010        };%%00010        return this;%%00010    };%%00010%%00010    LinePlot.LayoutObject = function (rep, val, gridColor) {%%00010        this.title = {%%00010            text: val.options.title,%%00010            y: 1,%%00010            yref: 'paper',%%00010            yanchor: 'bottom'%%00010        };%%00010        this.showlegend = val.options.showLegend;%%00010        this.autoSize = true;%%00010        this.legend = {%%00010            x: 1,%%00010            y: 1%%00010        };%%00010        this.font = {%%00010            size: 12,%%00010            family: 'sans-serif'%%00010        };%%00010        this.xaxis = {%%00010            title: val.options.xAxisLabel.length &gt; 0 ? val.options.xAxisLabel%%00010                : val.options.xAxisColumn,%%00010            font: {%%00010                size: 12,%%00010                family: 'sans-serif'%%00010            },%%00010            showgrid: val.options.showGrid,%%00010            gridcolor: gridColor,%%00010            linecolor: rep.options.gridColor,%%00010            linewidth: 1,%%00010            nticks: 10%%00010%%00010        };%%00010        this.yaxis = {%%00010            title: val.options.yAxisLabel.length &gt; 0 ? val.options.yAxisLabel%%00010                : 'y',%%00010            font: {%%00010                size: 12,%%00010                family: 'sans-serif'%%00010            },%%00010            showgrid: val.options.showGrid,%%00010            gridcolor: gridColor,%%00010            linecolor: rep.options.gridColor,%%00010            linewidth: 1,%%00010            nticks: 10%%00010        };%%00010        this.margin = {%%00010            l: 50,%%00010            r: 15,%%00010            b: 35,%%00010            t: 50,%%00010            pad: 0%%00010        };%%00010        this.hovermode = rep.options.tooltipToggle ? 'closest' : 'none';%%00010        this.paper_bgcolor = rep.options.backgroundColor || '#ffffff';%%00010        this.plot_bgcolor = rep.options.daColor || '#ffffff';%%00010    };%%00010%%00010    LinePlot.ConfigObject = function (rep, val) {%%00010        this.toImageButtonOptions = {%%00010            format: 'svg', // one of png, svg, jpeg, webp%%00010            filename: 'custom_image',%%00010            height: rep.options.svg ? rep.options.svg.height : 600,%%00010            width: rep.options.svg ? rep.options.svg.width : 800,%%00010            scale: 1 // Multiply title/legend/axis/canvas sizes by this factor%%00010        };%%00010        this.displaylogo = false;%%00010        this.responsive = rep.options.svg ? rep.options.svg.fullscreen : true;%%00010        this.editable = rep.options.enableEditing;%%00010        this.scrollZoom = true;%%00010        this.showTips = false;%%00010        this.showLink = rep.options.enablePlotlyEditor;%%00010        this.modeBarButtonsToRemove = ['hoverClosestCartesian',%%00010            'hoverCompareCartesian', 'toggleSpikelines'];%%00010        return this;%%00010    };%%00010%%00010    LinePlot.getSVG = function () {%%00010        return this.KPI.getSVG();%%00010    };%%00010%%00010    LinePlot.validate = function () {%%00010        return true;%%00010    };%%00010%%00010    LinePlot.getComponentValue = function () {%%00010        return this.KPI.getComponentValue();%%00010    };%%00010%%00010    LinePlot.onSelectionChange = function (data) {%%00010        if (data) {%%00010            this.KPI.updateSelected(data);%%00010            var changeObj = this.KPI.getFilteredChangeObject();%%00010            this.KPI.update(changeObj);%%00010        }%%00010    };%%00010%%00010    LinePlot.onFilterChange = function (data) {%%00010        if (data) {%%00010            this.KPI.updateFilter(data);%%00010            var changeObj = this.KPI.getFilteredChangeObject();%%00010            this.KPI.update(changeObj);%%00010        }%%00010    };%%00010%%00010    LinePlot.drawKnimeMenu = function () {%%00010%%00010        var self = this;%%00010%%00010        if (self.KPI.representation.options.enableViewControls) {%%00010%%00010            if (self.KPI.value.options.showFullscreen) {%%00010                knimeService.allowFullscreen();%%00010            }%%00010%%00010            if (self.KPI.representation.options.showClearSelectionButton &amp;&amp;%%00010                (self.KPI.representation.options.enableSelection ||%%00010                    (knimeService.isInteractivityAvailable() &amp;&amp;%%00010                        (self.KPI.value.options.subscribeToSelection ||%%00010                            self.KPI.representation.options.subscribeSelectionToggle))%%00010                )) {%%00010                knimeService.addButton(%%00010                    'clear-selection-button',%%00010                    'minus-square',%%00010                    'Clear Selection',%%00010                    function () {%%00010                        self.onSelectionChange({ points: [] });%%00010                    }%%00010                );%%00010            }%%00010%%00010            if (self.KPI.representation.options.enableFeatureSelection) {%%00010                var xAxisSelection = knimeService.createMenuSelect(%%00010                    'x-axis-menu-item',%%00010                    this.xAxisCol,%%00010                    this.columns,%%00010                    function () {%%00010                        if (self.xAxisCol !== this.value) {%%00010                            self.xAxisCol = this.value;%%00010                            var layoutObj = {%%00010                                'xaxis.title': self.xAxisCol%%00010                            };%%00010                            var keys = {%%00010                                dataKeys: [self.xAxisCol, null, null, null]%%00010                            };%%00010                            var valueObj = {%%00010                                xAxisColumn: self.xAxisCol%%00010                            };%%00010                            self.KPI.updateValue(valueObj);%%00010                            self.KPI.updateOrderedIndicies(self.xAxisCol);%%00010                            self.KPI.updateKeys(keys);%%00010                            self.KPI.update(false, layoutObj);%%00010                        }%%00010                    }%%00010                );%%00010%%00010                knimeService.addMenuItem(%%00010                    'X-Axis',%%00010                    'long-arrow-right',%%00010                    xAxisSelection,%%00010                    null,%%00010                    knimeService.SMALL_ICON%%00010                );%%00010%%00010                // temporarily use controlContainer to solve th resizing problem with ySelect%%00010                var controlContainer = this.KPI.Plotly.d3.select('#' + this.KPI.divID).insert('table', '#radarContainer ~ *')%%00010                    .attr('id', 'lineControls')%%00010                    /* .style(&quot;width&quot;, &quot;100%&quot;) */%%00010                    .style('padding', '10px')%%00010                    .style('margin', '0 auto')%%00010                    .style('box-sizing', 'border-box')%%00010                    .style('font-family', 'san-serif')%%00010                    .style('font-size', 12 + 'px')%%00010                    .style('border-spacing', 0)%%00010                    .style('border-collapse', 'collapse');%%00010                var columnChangeContainer = controlContainer.append('tr');%%00010                var columnSelect = new twinlistMultipleSelections();%%00010                var columnSelectComponent = columnSelect.getComponent().get(0);%%00010                columnChangeContainer.append('td').attr('colspan', '3').node().appendChild(columnSelectComponent);%%00010                columnSelect.setChoices(this.numericColumns);%%00010                columnSelect.setSelections(this.lineColumns);%%00010                columnSelect.addValueChangedListener(function () {%%00010                    self.columns = columnSelect.getSelections();%%00010                    var valObj = {%%00010                        columns: self.columns%%00010                    };%%00010                    var changeObj = {%%00010                        visible: []%%00010                    };%%00010                    self.KPI.traceDirectory.forEach(function (trace) {%%00010                        if (self.columns.indexOf(trace.dataKeys[1]) &gt; -1) {%%00010                            changeObj.visible.push(true);%%00010                        } else {%%00010                            changeObj.visible.push(false);%%00010                        }%%00010                    });%%00010                    self.KPI.updateValue(valObj);%%00010                    self.KPI.update(changeObj);%%00010                });%%00010                knimeService.addMenuItem('Columns (lines):', 'long-arrow-up', columnSelectComponent);%%00010                controlContainer.remove();%%00010%%00010                knimeService.addMenuDivider();%%00010            }%%00010%%00010            if (self.KPI.representation.options.tooltipToggle) {%%00010%%00010                var tooltipToggleCheckBox = knimeService.createMenuCheckbox(%%00010                    'show-tooltips-checkbox',%%00010                    self.KPI.representation.options.tooltipToggle,%%00010                    function () {%%00010                        if (self.KPI.representation.options.tooltipToggle !== this.checked) {%%00010                            self.KPI.representation.options.tooltipToggle = this.checked;%%00010                            var layoutObj = {%%00010                                hovermode: self.KPI.representation.options.tooltipToggle%%00010                                    ? 'closest' : false%%00010                            };%%00010                            self.KPI.update(false, layoutObj, true);%%00010                        }%%00010                    },%%00010                    true%%00010                );%%00010%%00010                knimeService.addMenuItem(%%00010                    'Show tooltips',%%00010                    'info',%%00010                    tooltipToggleCheckBox,%%00010                    null,%%00010                    knimeService.SMALL_ICON%%00010                );%%00010%%00010                knimeService.addMenuDivider();%%00010%%00010            }%%00010%%00010            if (self.KPI.representation.options.showSelectedOnlyToggle &amp;&amp;%%00010                (self.KPI.representation.options.enableSelection || (knimeService.isInteractivityAvailable() &amp;&amp;%%00010                    (self.KPI.representation.options.subscribeSelectionToggle || self.KPI.value.options.subscribeToSelection)))) {%%00010%%00010                var showOnlySelectedCheckbox = knimeService.createMenuCheckbox(%%00010                    'show-only-selected-checkbox',%%00010                    this.showOnlySelected,%%00010                    function () {%%00010                        if (self.showOnlySelected !== this.checked) {%%00010                            self.KPI.updateShowOnlySelected(this.checked);%%00010                            self.KPI.update();%%00010                        }%%00010                    },%%00010                    true%%00010                );%%00010%%00010                knimeService.addMenuItem(%%00010                    'Show Only Selected',%%00010                    'filter',%%00010                    showOnlySelectedCheckbox,%%00010                    null,%%00010                    knimeService.SMALL_ICON%%00010                );%%00010%%00010                knimeService.addMenuDivider();%%00010%%00010            }%%00010%%00010            if (knimeService.isInteractivityAvailable()) {%%00010%%00010                if (self.KPI.representation.options.enableSelection &amp;&amp;%%00010                    self.KPI.representation.options.publishSelectionToggle) {%%00010%%00010                    var publishSelectionCheckbox = knimeService.createMenuCheckbox(%%00010                        'publish-selection-checkbox',%%00010                        self.KPI.value.options.publishSelection,%%00010                        function () {%%00010                            if (self.KPI.value.options.publishSelection !== this.checked) {%%00010                                self.KPI.value.options.publishSelection = this.checked;%%00010                                self.KPI.togglePublishSelection(self.onSelectionChange);%%00010                            }%%00010                        },%%00010                        true%%00010                    );%%00010%%00010                    knimeService.addMenuItem(%%00010                        'Publish Selection',%%00010                        knimeService.createStackedIcon('check-square-o',%%00010                            'angle-right', 'faded left sm', 'right bold'),%%00010                        publishSelectionCheckbox,%%00010                        null,%%00010                        knimeService.SMALL_ICON%%00010                    );%%00010%%00010                }%%00010%%00010                if (self.KPI.representation.options.subscribeSelectionToggle) {%%00010%%00010                    var subscribeToSelectionCheckbox = knimeService.createMenuCheckbox(%%00010                        'subscribe-to-selection-checkbox',%%00010                        self.KPI.value.options.subscribeToSelection,%%00010                        function () {%%00010                            if (self.KPI.value.options.subscribeToSelection !== this.checked) {%%00010                                self.KPI.value.options.subscribeToSelection = this.checked;%%00010                                self.KPI.toggleSubscribeToSelection(self.onSelectionChange);%%00010                            }%%00010                        },%%00010                        true%%00010                    );%%00010%%00010                    knimeService.addMenuItem(%%00010                        'Subscribe to Selection',%%00010                        knimeService.createStackedIcon('check-square-o',%%00010                            'angle-double-right', 'faded right sm', 'left bold'),%%00010                        subscribeToSelectionCheckbox,%%00010                        null,%%00010                        knimeService.SMALL_ICON%%00010                    );%%00010                }%%00010%%00010                if (self.KPI.representation.options.subscribeFilterToggle) {%%00010%%00010                    var subscribeToFilterCheckbox = knimeService.createMenuCheckbox(%%00010                        'subscribe-to-filter-checkbox',%%00010                        self.KPI.value.options.subscribeToFilters,%%00010                        function () {%%00010                            if (self.KPI.value.options.subscribeToFilters !== this.checked) {%%00010                                self.KPI.value.options.subscribeToFilters = this.checked;%%00010                                self.KPI.toggleSubscribeToFilters(self.onFilterChange);%%00010                            }%%00010                        },%%00010                        true%%00010                    );%%00010%%00010                    knimeService.addMenuItem(%%00010                        'Subscribe to Filter',%%00010                        knimeService.createStackedIcon('filter',%%00010                            'angle-double-right', 'faded right sm', 'left bold'),%%00010                        subscribeToFilterCheckbox,%%00010                        null,%%00010                        knimeService.SMALL_ICON%%00010                    );%%00010                }%%00010            }%%00010        }%%00010    };%%00010%%00010    return LinePlot;%%00010%%00010})();%%00010"/>
</config>
<config key="cssCode">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="#knime-line {%%00010%%00009width: 100%;%%00010%%00009height: 100vh;%%00010}%%00010%%00010.js-plotly-plot .plotly .modebar{%%00010    left: 2px !important;%%00010    top: 12px !important%%00010}%%00010%%00010.js-plotly-plot .plotly [data-title]::before, .js-plotly-plot .plotly [data-title]::after {%%00010    z-index: 2001 !important;%%00010    margin-right: -300% !important;%%00010    margin-top: -10% !important;%%00010    padding: 8px 5px !important;%%00010}%%00010%%00010.notifier-note &gt; * {%%00010    font-family: &quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif;%%00010    font-size: 14px;%%00010}%%00010%%00010.gtitle {%%00010    font-size: 24px !important;%%00010}"/>
</config>
<config key="jsDependencies">
<entry key="numSettings" type="xint" value="9"/>
<config key="dependency_0">
<entry key="name" type="xstring" value="Moment"/>
<entry key="path" type="xstring" value="js-lib/moment/2_17/timezone/moment-timezone-with-data.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" value="moment"/>
<config key="dependencies">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="moment_locales_2_17"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_1">
<entry key="name" type="xstring" value="moment_locales_2_17"/>
<entry key="path" type="xstring" value="js-lib/moment/2_17/locales/moment-with-locales.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" isnull="true" value=""/>
<config key="dependencies">
<entry key="array-size" type="xint" value="0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_2">
<entry key="name" type="xstring" value="Plotly"/>
<entry key="path" type="xstring" value="js-lib/plotly/1.47.4/plotly.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" value="Plotly"/>
<config key="dependencies">
<entry key="array-size" type="xint" value="0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_3">
<entry key="name" type="xstring" value="MultipleSelections"/>
<entry key="path" type="xstring" value="org/knime/js/base/dialog/selection/multiple/TwinlistMultipleSelections.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" value="MultipleSelections"/>
<config key="dependencies">
<entry key="array-size" type="xint" value="2"/>
<entry key="0" type="xstring" value="jQuery_1.11.0"/>
<entry key="1" type="xstring" value="KnimeTwinlist_1.0.0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_4">
<entry key="name" type="xstring" value="MultipleSelections"/>
<entry key="path" type="xstring" value="org/knime/js/base/dialog/selection/multiple/TwinlistMultipleSelections.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" value="MultipleSelections"/>
<config key="dependencies">
<entry key="array-size" type="xint" value="2"/>
<entry key="0" type="xstring" value="jQuery_1.11.0"/>
<entry key="1" type="xstring" value="KnimeTwinlist_1.0.0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_5">
<entry key="name" type="xstring" value="MultipleSelections"/>
<entry key="path" type="xstring" value="org/knime/js/base/dialog/selection/multiple/TwinlistMultipleSelections.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" value="MultipleSelections"/>
<config key="dependencies">
<entry key="array-size" type="xint" value="2"/>
<entry key="0" type="xstring" value="jQuery_1.11.0"/>
<entry key="1" type="xstring" value="KnimeTwinlist_1.0.0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_6">
<entry key="name" type="xstring" value="jQuery_1.11.0"/>
<entry key="path" type="xstring" value="js-lib/jQuery/jquery-1.11.0.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" isnull="true" value=""/>
<config key="dependencies">
<entry key="array-size" type="xint" value="0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_7">
<entry key="name" type="xstring" value="KnimeTwinlist_1.0.0"/>
<entry key="path" type="xstring" value="js-lib/knime/knime_twinlist_1_0_0.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" isnull="true" value=""/>
<config key="dependencies">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" value="jQuery_1.11.0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
<config key="dependency_8">
<entry key="name" type="xstring" value="jQuery_1.11.0"/>
<entry key="path" type="xstring" value="js-lib/jQuery/jquery-1.11.0.min.js"/>
<entry key="usesDefine" type="xboolean" value="false"/>
<entry key="exports" type="xstring" isnull="true" value=""/>
<config key="dependencies">
<entry key="array-size" type="xint" value="0"/>
</config>
<entry key="local" type="xboolean" value="true"/>
</config>
</config>
<config key="cssDependencies">
<entry key="array-size" type="xint" value="0"/>
</config>
<entry key="new" type="xboolean" value="false"/>
<entry key="inView" type="xboolean" value="true"/>
<config key="tableIds">
<entry key="array-size" type="xint" value="1"/>
<entry key="0" type="xstring" isnull="true" value=""/>
</config>
<config key="variables">
<entry key="numSettings" type="xint" value="1"/>
<entry key="mapClass" type="xstring" value="string"/>
<entry key="key_0" type="xstring" value="knime.workspace"/>
<entry key="class_0" type="xstring" value="java.lang.String"/>
<entry key="value_0" type="xstring" value="/home/knoldus/Documents/Knime-workspace"/>
</config>
<config key="binaryFiles">
<entry key="numSettings" type="xint" value="0"/>
<entry key="mapClass" type="xstring" value="string"/>
</config>
<config key="options">
<entry key="numSettings" type="xint" value="19"/>
<entry key="mapClass" type="xstring" value="object"/>
<entry key="key_0" type="xstring" value="backgroundColor"/>
<entry key="class_0" type="xstring" value="java.lang.String"/>
<entry key="value_0" type="xstring" value="#FFFFFF"/>
<entry key="key_1" type="xstring" value="showClearSelectionButton"/>
<entry key="class_1" type="xstring" value="java.lang.Boolean"/>
<entry key="value_1" type="xboolean" value="true"/>
<entry key="key_2" type="xstring" value="enableEditing"/>
<entry key="class_2" type="xstring" value="java.lang.Boolean"/>
<entry key="value_2" type="xboolean" value="true"/>
<entry key="key_3" type="xstring" value="svg"/>
<entry key="class_3" type="xstring" value="org.knime.dynamic.js.SettingsModelSVGOptions$JSONSVGOptions"/>
<config key="value_3">
<entry key="width" type="xint" value="800"/>
<entry key="height" type="xint" value="600"/>
<entry key="fullscreen" type="xboolean" value="true"/>
</config>
<entry key="key_4" type="xstring" value="enableGL"/>
<entry key="class_4" type="xstring" value="java.lang.Boolean"/>
<entry key="value_4" type="xboolean" value="false"/>
<entry key="key_5" type="xstring" value="enableSelection"/>
<entry key="class_5" type="xstring" value="java.lang.Boolean"/>
<entry key="value_5" type="xboolean" value="true"/>
<entry key="key_6" type="xstring" value="overrideColors"/>
<entry key="class_6" type="xstring" value="java.lang.Boolean"/>
<entry key="value_6" type="xboolean" value="false"/>
<entry key="key_7" type="xstring" value="showSelectedOnlyToggle"/>
<entry key="class_7" type="xstring" value="java.lang.Boolean"/>
<entry key="value_7" type="xboolean" value="true"/>
<entry key="key_8" type="xstring" value="tooltipToggle"/>
<entry key="class_8" type="xstring" value="java.lang.Boolean"/>
<entry key="value_8" type="xboolean" value="true"/>
<entry key="key_9" type="xstring" value="dataColor"/>
<entry key="class_9" type="xstring" value="java.lang.String"/>
<entry key="value_9" type="xstring" value="#0000FF"/>
<entry key="key_10" type="xstring" value="enablePlotlyEditor"/>
<entry key="class_10" type="xstring" value="java.lang.Boolean"/>
<entry key="value_10" type="xboolean" value="true"/>
<entry key="key_11" type="xstring" value="publishSelectionToggle"/>
<entry key="class_11" type="xstring" value="java.lang.Boolean"/>
<entry key="value_11" type="xboolean" value="true"/>
<entry key="key_12" type="xstring" value="subscribeSelectionToggle"/>
<entry key="class_12" type="xstring" value="java.lang.Boolean"/>
<entry key="value_12" type="xboolean" value="true"/>
<entry key="key_13" type="xstring" value="gridColor"/>
<entry key="class_13" type="xstring" value="java.lang.String"/>
<entry key="value_13" type="xstring" value="#000000"/>
<entry key="key_14" type="xstring" value="enableFeatureSelection"/>
<entry key="class_14" type="xstring" value="java.lang.Boolean"/>
<entry key="value_14" type="xboolean" value="true"/>
<entry key="key_15" type="xstring" value="enableViewControls"/>
<entry key="class_15" type="xstring" value="java.lang.Boolean"/>
<entry key="value_15" type="xboolean" value="true"/>
<entry key="key_16" type="xstring" value="reportMissing"/>
<entry key="class_16" type="xstring" value="java.lang.Boolean"/>
<entry key="value_16" type="xboolean" value="true"/>
<entry key="key_17" type="xstring" value="subscribeFilterToggle"/>
<entry key="class_17" type="xstring" value="java.lang.Boolean"/>
<entry key="value_17" type="xboolean" value="true"/>
<entry key="key_18" type="xstring" value="daColor"/>
<entry key="class_18" type="xstring" value="java.lang.String"/>
<entry key="value_18" type="xstring" value="#FFFFFF"/>
</config>
<config key="inObjects">
<entry key="numSettings" type="xint" value="1"/>
<config key="inObject_0">
<entry key="knimeDataTableJSON" type="xstring" value="{&quot;@class&quot;:&quot;org.knime.js.core.JSONDataTable&quot;,&quot;filtered&quot;:false,&quot;fragmentFirstRowIndex&quot;:0,&quot;totalFilteredRows&quot;:0,&quot;totalRows&quot;:0,&quot;dataHash&quot;:null,&quot;rows&quot;:[{&quot;rowKey&quot;:&quot;Row0&quot;,&quot;data&quot;:[1.0,479.0,1302.0,744.0,473.0,381.0,1245.0,1274.0,1671.0,1054.0,1564.0,1543.0,1512.0,1746.0,1226.0,1939.0,546.0,722.0,1872.0,825.0,994.0,823.0,1703.0,638.0,1371.0,1764.0,961.0,494.0,1919.0,1582.0,832.0,1240.0,902.0,1523.0,569.0,1379.0,1655.0,612.0,1721.0,928.0,633.0,526.0,749.0,1104.0,639.0,1689.0,1262.0,487.0,1110.0,624.0,1360.0]},{&quot;rowKey&quot;:&quot;Row1&quot;,&quot;data&quot;:[2.0,466.0,1285.0,800.0,516.0,397.0,1355.0,1155.0,1666.0,1028.0,1672.0,1547.0,1456.0,1775.0,1222.0,1944.0,513.0,698.0,1814.0,909.0,1017.0,878.0,1795.0,657.0,1468.0,1735.0,1020.0,483.0,1939.0,1481.0,883.0,1214.0,958.0,1566.0,543.0,1379.0,1663.0,629.0,1839.0,920.0,659.0,487.0,740.0,1158.0,625.0,1787.0,1275.0,422.0,1095.0,651.0,1466.0]},{&quot;rowKey&quot;:&quot;Row2&quot;,&quot;data&quot;:[3.0,487.0,1261.0,823.0,426.0,385.0,1220.0,1258.0,1692.0,1100.0,1646.0,1459.0,1466.0,1843.0,1186.0,1900.0,569.0,725.0,1827.0,864.0,1004.0,857.0,1790.0,663.0,1454.0,1725.0,995.0,481.0,1909.0,1517.0,831.0,1290.0,973.0,1506.0,575.0,1461.0,1662.0,628.0,1697.0,932.0,615.0,408.0,815.0,1067.0,642.0,1743.0,1287.0,442.0,1095.0,621.0,1401.0]},{&quot;rowKey&quot;:&quot;Row3&quot;,&quot;data&quot;:[4.0,468.0,1244.0,777.0,469.0,390.0,1233.0,1262.0,1662.0,1163.0,1580.0,1505.0,1514.0,1798.0,1274.0,1863.0,505.0,724.0,1878.0,871.0,980.0,875.0,1719.0,638.0,1412.0,1696.0,995.0,484.0,1851.0,1583.0,875.0,1276.0,910.0,1454.0,539.0,1467.0,1593.0,619.0,1814.0,923.0,638.0,479.0,794.0,1022.0,628.0,1716.0,1259.0,508.0,1135.0,630.0,1379.0]},{&quot;rowKey&quot;:&quot;Row4&quot;,&quot;data&quot;:[5.0,509.0,1253.0,780.0,510.0,447.0,1289.0,1285.0,1650.0,1170.0,1588.0,1566.0,1548.0,1848.0,1303.0,1983.0,532.0,719.0,1758.0,863.0,1018.0,848.0,1749.0,628.0,1487.0,1740.0,1076.0,459.0,2006.0,1533.0,879.0,1261.0,965.0,1480.0,562.0,1443.0,1727.0,652.0,1788.0,982.0,656.0,465.0,811.0,1067.0,655.0,1772.0,1310.0,478.0,1157.0,615.0,1483.0]},{&quot;rowKey&quot;:&quot;Row5&quot;,&quot;data&quot;:[6.0,499.0,1370.0,889.0,506.0,434.0,1400.0,1371.0,1861.0,1214.0,1705.0,1677.0,1609.0,1932.0,1381.0,2130.0,628.0,774.0,1992.0,960.0,1094.0,926.0,1945.0,694.0,1625.0,1840.0,1143.0,526.0,2163.0,1697.0,988.0,1395.0,1085.0,1597.0,619.0,1562.0,1776.0,711.0,1917.0,997.0,672.0,538.0,871.0,1239.0,670.0,1946.0,1373.0,505.0,1231.0,672.0,1538.0]},{&quot;rowKey&quot;:&quot;Row6&quot;,&quot;data&quot;:[7.0,508.0,1440.0,890.0,533.0,438.0,1405.0,1402.0,1791.0,1263.0,1696.0,1683.0,1629.0,2092.0,1513.0,2056.0,666.0,796.0,2054.0,995.0,1139.0,950.0,1970.0,698.0,1541.0,1895.0,1154.0,508.0,2035.0,1615.0,896.0,1356.0,1083.0,1622.0,607.0,1639.0,1793.0,694.0,1967.0,1050.0,710.0,519.0,875.0,1197.0,702.0,1889.0,1424.0,519.0,1235.0,725.0,1610.0]},{&quot;rowKey&quot;:&quot;Row7&quot;,&quot;data&quot;:[8.0,523.0,1414.0,871.0,522.0,452.0,1402.0,1351.0,1856.0,1206.0,1794.0,1650.0,1638.0,2098.0,1453.0,2190.0,643.0,797.0,1936.0,989.0,1153.0,996.0,1971.0,692.0,1522.0,1907.0,1142.0,477.0,2073.0,1624.0,1001.0,1391.0,1057.0,1662.0,632.0,1639.0,1851.0,726.0,1850.0,991.0,717.0,520.0,924.0,1183.0,687.0,1917.0,1369.0,509.0,1267.0,652.0,1551.0]},{&quot;rowKey&quot;:&quot;Row8&quot;,&quot;data&quot;:[9.0,517.0,1463.0,892.0,559.0,451.0,1497.0,1426.0,1921.0,1310.0,1762.0,1721.0,1696.0,2037.0,1481.0,2217.0,627.0,802.0,2082.0,967.0,1217.0,980.0,1984.0,684.0,1660.0,2013.0,1127.0,552.0,2139.0,1762.0,1058.0,1388.0,1079.0,1774.0,643.0,1644.0,1862.0,735.0,1994.0,1100.0,720.0,544.0,962.0,1268.0,721.0,2022.0,1528.0,567.0,1248.0,696.0,1620.0]},{&quot;rowKey&quot;:&quot;Row9&quot;,&quot;data&quot;:[10.0,556.0,1691.0,980.0,598.0,522.0,1756.0,1684.0,2208.0,1502.0,2121.0,2001.0,2021.0,2364.0,1579.0,2478.0,705.0,894.0,2322.0,1122.0,1417.0,1111.0,2292.0,835.0,1935.0,2276.0,1361.0,658.0,2426.0,1960.0,1116.0,1632.0,1226.0,2003.0,696.0,1780.0,2214.0,860.0,2244.0,1230.0,881.0,585.0,1016.0,1442.0,871.0,2254.0,1656.0,584.0,1568.0,840.0,1883.0]},{&quot;rowKey&quot;:&quot;Row10&quot;,&quot;data&quot;:[11.0,612.0,1731.0,1058.0,623.0,509.0,1713.0,1658.0,2195.0,1484.0,2105.0,2069.0,2026.0,2470.0,1657.0,2419.0,723.0,958.0,2390.0,1116.0,1328.0,1130.0,2363.0,861.0,1892.0,2332.0,1354.0,668.0,2499.0,2017.0,1165.0,1716.0,1311.0,1957.0,710.0,1817.0,2192.0,877.0,2302.0,1287.0,777.0,631.0,1062.0,1387.0,828.0,2281.0,1564.0,673.0,1474.0,812.0,1879.0]},{&quot;rowKey&quot;:&quot;Row11&quot;,&quot;data&quot;:[12.0,679.0,1642.0,1056.0,631.0,538.0,1695.0,1666.0,2167.0,1460.0,2009.0,2027.0,1917.0,2389.0,1738.0,2519.0,746.0,933.0,2370.0,1098.0,1384.0,1120.0,2214.0,865.0,1843.0,2331.0,1387.0,633.0,2548.0,1948.0,1234.0,1658.0,1244.0,2078.0,735.0,1915.0,2279.0,777.0,2363.0,1265.0,803.0,622.0,1028.0,1485.0,831.0,2305.0,1682.0,620.0,1487.0,789.0,1885.0]},{&quot;rowKey&quot;:&quot;Row12&quot;,&quot;data&quot;:[13.0,602.0,1634.0,1039.0,629.0,561.0,1697.0,1666.0,2292.0,1433.0,2169.0,1938.0,2048.0,2395.0,1693.0,2500.0,736.0,926.0,2398.0,1157.0,1423.0,1202.0,2317.0,841.0,1927.0,2330.0,1383.0,610.0,2540.0,1957.0,1174.0,1733.0,1269.0,1981.0,730.0,1864.0,2198.0,817.0,2269.0,1248.0,854.0,653.0,1087.0,1451.0,868.0,2266.0,1668.0,647.0,1528.0,854.0,1829.0]},{&quot;rowKey&quot;:&quot;Row13&quot;,&quot;data&quot;:[14.0,714.0,1861.0,1167.0,730.0,597.0,1916.0,1898.0,2517.0,1627.0,2365.0,2251.0,2306.0,2676.0,1847.0,2815.0,874.0,1069.0,2696.0,1331.0,1562.0,1325.0,2607.0,927.0,2115.0,2479.0,1565.0,717.0,2829.0,2113.0,1284.0,1823.0,1465.0,2267.0,830.0,2092.0,2452.0,936.0,2654.0,1423.0,930.0,710.0,1228.0,1517.0,963.0,2566.0,1894.0,687.0,1608.0,909.0,2108.0]},{&quot;rowKey&quot;:&quot;Row14&quot;,&quot;data&quot;:[15.0,692.0,2095.0,1221.0,742.0,622.0,1958.0,1974.0,2618.0,1739.0,2424.0,2367.0,2325.0,2718.0,2027.0,2953.0,891.0,1098.0,2780.0,1323.0,1640.0,1319.0,2641.0,986.0,2237.0,2641.0,1582.0,753.0,2865.0,2395.0,1311.0,1973.0,1497.0,2224.0,787.0,2182.0,2558.0,1010.0,2778.0,1523.0,993.0,748.0,1241.0,1765.0,976.0,2658.0,1883.0,691.0,1714.0,1024.0,2214.0]},{&quot;rowKey&quot;:&quot;Row15&quot;,&quot;data&quot;:[16.0,759.0,1870.0,1188.0,749.0,604.0,1935.0,1940.0,2555.0,1764.0,2465.0,2362.0,2358.0,2791.0,1920.0,3026.0,857.0,1150.0,2774.0,1333.0,1503.0,1311.0,2715.0,935.0,2241.0,2625.0,1587.0,736.0,2912.0,2343.0,1314.0,1946.0,1518.0,2370.0,889.0,2171.0,2631.0,944.0,2711.0,1466.0,906.0,753.0,1161.0,1780.0,952.0,2612.0,2014.0,692.0,1688.0,969.0,2166.0]},{&quot;rowKey&quot;:&quot;Row16&quot;,&quot;data&quot;:[17.0,707.0,1991.0,1273.0,749.0,634.0,1960.0,1919.0,2503.0,1648.0,2473.0,2326.0,2349.0,2770.0,1980.0,3063.0,914.0,1109.0,2835.0,1306.0,1529.0,1360.0,2716.0,987.0,2194.0,2734.0,1676.0,752.0,2962.0,2319.0,1345.0,1938.0,1500.0,2416.0,841.0,2295.0,2484.0,979.0,2589.0,1433.0,986.0,744.0,1225.0,1703.0,966.0,2653.0,1974.0,707.0,1756.0,956.0,2177.0]},{&quot;rowKey&quot;:&quot;Row17&quot;,&quot;data&quot;:[18.0,761.0,1992.0,1271.0,780.0,580.0,2001.0,2061.0,2682.0,1822.0,2543.0,2358.0,2463.0,2945.0,2035.0,2952.0,870.0,1081.0,2979.0,1313.0,1647.0,1400.0,2853.0,985.0,2290.0,2748.0,1643.0,764.0,3043.0,2375.0,1421.0,2000.0,1524.0,2466.0,899.0,2227.0,2587.0,986.0,2713.0,1564.0,987.0,781.0,1219.0,1718.0,991.0,2805.0,1972.0,798.0,1832.0,1027.0,2253.0]},{&quot;rowKey&quot;:&quot;Row18&quot;,&quot;data&quot;:[19.0,732.0,2218.0,1337.0,786.0,662.0,2076.0,2056.0,2778.0,1892.0,2615.0,2514.0,2493.0,3084.0,2092.0,3182.0,947.0,1135.0,3014.0,1465.0,1660.0,1409.0,2810.0,1014.0,2288.0,2830.0,1772.0,766.0,3093.0,2441.0,1399.0,2012.0,1534.0,2438.0,964.0,2323.0,2771.0,1042.0,2891.0,1527.0,969.0,800.0,1374.0,1782.0,1065.0,2920.0,2171.0,762.0,1841.0,1017.0,2338.0]},{&quot;rowKey&quot;:&quot;Row19&quot;,&quot;data&quot;:[20.0,773.0,2131.0,1353.0,795.0,684.0,2120.0,2159.0,2711.0,1763.0,2683.0,2496.0,2543.0,3017.0,2080.0,3231.0,966.0,1195.0,3126.0,1479.0,1709.0,1397.0,2806.0,1032.0,2374.0,2867.0,1723.0,787.0,3274.0,2498.0,1457.0,2078.0,1616.0,2490.0,936.0,2451.0,2750.0,1022.0,2894.0,1633.0,1077.0,791.0,1395.0,1805.0,1103.0,2839.0,2038.0,801.0,1820.0,1051.0,2319.0]},{&quot;rowKey&quot;:&quot;Row20&quot;,&quot;data&quot;:[21.0,834.0,2101.0,1385.0,794.0,687.0,2125.0,2122.0,2614.0,1836.0,2592.0,2481.0,2428.0,2955.0,2040.0,3146.0,920.0,1186.0,3086.0,1441.0,1720.0,1470.0,2849.0,1022.0,2291.0,2919.0,1770.0,791.0,3195.0,2469.0,1399.0,2095.0,1524.0,2429.0,898.0,2322.0,2702.0,1028.0,2841.0,1544.0,1094.0,805.0,1275.0,1824.0,1118.0,2861.0,2137.0,802.0,1880.0,1064.0,2343.0]},{&quot;rowKey&quot;:&quot;Row21&quot;,&quot;data&quot;:[22.0,801.0,2131.0,1410.0,797.0,645.0,2064.0,2177.0,2813.0,1876.0,2630.0,2519.0,2485.0,3064.0,2112.0,3226.0,918.0,1190.0,3083.0,1455.0,1712.0,1461.0,2945.0,1042.0,2432.0,2858.0,1721.0,848.0,3122.0,2520.0,1498.0,2151.0,1560.0,2429.0,932.0,2386.0,2899.0,991.0,2906.0,1651.0,1106.0,789.0,1325.0,1867.0,1054.0,2892.0,2142.0,800.0,1830.0,1080.0,2390.0]},{&quot;rowKey&quot;:&quot;Row22&quot;,&quot;data&quot;:[23.0,817.0,2268.0,1383.0,872.0,719.0,2222.0,2224.0,2954.0,1967.0,2765.0,2573.0,2564.0,3119.0,2177.0,3437.0,903.0,1264.0,3149.0,1476.0,1767.0,1545.0,3065.0,1118.0,2515.0,3081.0,1775.0,862.0,3435.0,2677.0,1509.0,2220.0,1724.0,2647.0,971.0,2446.0,2847.0,1093.0,3137.0,1656.0,1105.0,873.0,1385.0,2004.0,1118.0,3085.0,2165.0,790.0,1953.0,1069.0,2450.0]},{&quot;rowKey&quot;:&quot;Row23&quot;,&quot;data&quot;:[24.0,874.0,2197.0,1425.0,834.0,747.0,2164.0,2300.0,2936.0,1965.0,2757.0,2598.0,2692.0,3211.0,2314.0,3293.0,986.0,1249.0,3257.0,1578.0,1846.0,1558.0,2960.0,1119.0,2553.0,3079.0,1777.0,860.0,3407.0,2713.0,1528.0,2129.0,1709.0,2641.0,1002.0,2540.0,2902.0,1111.0,3171.0,1659.0,1153.0,842.0,1384.0,1987.0,1115.0,3133.0,2286.0,831.0,1867.0,1041.0,2606.0]},{&quot;rowKey&quot;:&quot;Row24&quot;,&quot;data&quot;:[25.0,857.0,2166.0,1411.0,834.0,647.0,2217.0,2209.0,3018.0,2025.0,2792.0,2700.0,2712.0,3249.0,2276.0,3271.0,1024.0,1241.0,3214.0,1498.0,1807.0,1482.0,2996.0,1057.0,2566.0,3105.0,1890.0,823.0,3380.0,2644.0,1537.0,2177.0,1660.0,2672.0,973.0,2460.0,2812.0,1114.0,3186.0,1625.0,1132.0,874.0,1380.0,2019.0,1079.0,3042.0,2242.0,822.0,1969.0,1150.0,2554.0]},{&quot;rowKey&quot;:&quot;Row25&quot;,&quot;data&quot;:[26.0,905.0,2276.0,1357.0,851.0,688.0,2232.0,2211.0,2927.0,1932.0,2677.0,2589.0,2702.0,3344.0,2113.0,3438.0,999.0,1280.0,3257.0,1555.0,1790.0,1557.0,3054.0,1100.0,2577.0,3026.0,1830.0,823.0,3395.0,2574.0,1512.0,2254.0,1612.0,2660.0,960.0,2609.0,3005.0,1114.0,3130.0,1644.0,1111.0,861.0,1391.0,1962.0,1191.0,2967.0,2187.0,822.0,1995.0,1131.0,2504.0]},{&quot;rowKey&quot;:&quot;Row26&quot;,&quot;data&quot;:[27.0,889.0,2314.0,1384.0,891.0,722.0,2264.0,2349.0,2957.0,2093.0,2951.0,2779.0,2703.0,3289.0,2298.0,3547.0,1045.0,1335.0,3442.0,1644.0,1825.0,1559.0,3233.0,1199.0,2608.0,3168.0,1897.0,950.0,3501.0,2780.0,1558.0,2305.0,1790.0,2773.0,1050.0,2559.0,3167.0,1122.0,3311.0,1810.0,1114.0,867.0,1463.0,2100.0,1222.0,3157.0,2299.0,885.0,2030.0,1172.0,2535.0]},{&quot;rowKey&quot;:&quot;Row27&quot;,&quot;data&quot;:[28.0,931.0,2296.0,1461.0,917.0,720.0,2363.0,2295.0,3097.0,2077.0,2993.0,2830.0,2977.0,3272.0,2455.0,3512.0,980.0,1344.0,3502.0,1701.0,1885.0,1645.0,3220.0,1187.0,2671.0,3271.0,1951.0,862.0,3512.0,2820.0,1700.0,2437.0,1738.0,2743.0,1038.0,2754.0,3218.0,1240.0,3152.0,1740.0,1225.0,870.0,1441.0,2126.0,1250.0,3272.0,2372.0,928.0,2153.0,1153.0,2600.0]},{&quot;rowKey&quot;:&quot;Row28&quot;,&quot;data&quot;:[29.0,901.0,2459.0,1522.0,843.0,716.0,2416.0,2417.0,3021.0,2105.0,2933.0,2869.0,2869.0,3350.0,2326.0,3688.0,1057.0,1362.0,3431.0,1651.0,1891.0,1665.0,3230.0,1194.0,2683.0,3299.0,1972.0,902.0,3506.0,2878.0,1607.0,2407.0,1790.0,2825.0,1071.0,2617.0,3186.0,1216.0,3313.0,1809.0,1190.0,871.0,1459.0,2098.0,1198.0,3361.0,2354.0,899.0,2160.0,1225.0,2731.0]},{&quot;rowKey&quot;:&quot;Row29&quot;,&quot;data&quot;:[30.0,923.0,2348.0,1540.0,929.0,771.0,2365.0,2317.0,3131.0,2075.0,2926.0,2844.0,2884.0,3433.0,2391.0,3520.0,1057.0,1317.0,3453.0,1661.0,1922.0,1615.0,3227.0,1232.0,2759.0,3220.0,1992.0,864.0,3457.0,2883.0,1554.0,2346.0,1778.0,2839.0,1095.0,2682.0,3124.0,1153.0,3314.0,1801.0,1195.0,888.0,1435.0,2051.0,1183.0,3382.0,2341.0,900.0,2152.0,1147.0,2645.0]},{&quot;rowKey&quot;:&quot;Row30&quot;,&quot;data&quot;:[31.0,848.0,2323.0,1417.0,807.0,667.0,2346.0,2328.0,2915.0,1979.0,2836.0,2833.0,2743.0,3338.0,2274.0,3482.0,1051.0,1309.0,3272.0,1611.0,1758.0,1542.0,3154.0,1162.0,2590.0,3187.0,1873.0,891.0,3413.0,2747.0,1552.0,2284.0,1727.0,2737.0,1000.0,2473.0,2942.0,1191.0,3162.0,1698.0,1153.0,838.0,1324.0,2021.0,1080.0,3227.0,2298.0,830.0,1965.0,1110.0,2610.0]},{&quot;rowKey&quot;:&quot;Row31&quot;,&quot;data&quot;:[32.0,829.0,2163.0,1278.0,830.0,652.0,2123.0,2127.0,2743.0,1798.0,2635.0,2462.0,2516.0,3099.0,2167.0,3112.0,935.0,1190.0,3002.0,1488.0,1731.0,1464.0,2918.0,1011.0,2282.0,2905.0,1702.0,771.0,3178.0,2520.0,1461.0,2144.0,1576.0,2520.0,978.0,2394.0,2738.0,1031.0,2910.0,1562.0,1054.0,797.0,1288.0,1848.0,1018.0,2897.0,2135.0,791.0,1780.0,1124.0,2385.0]},{&quot;rowKey&quot;:&quot;Row32&quot;,&quot;data&quot;:[33.0,765.0,2052.0,1290.0,796.0,710.0,2159.0,1997.0,2705.0,1905.0,2651.0,2548.0,2575.0,2958.0,2141.0,3174.0,934.0,1287.0,3070.0,1472.0,1677.0,1459.0,2775.0,999.0,2493.0,2868.0,1734.0,846.0,3113.0,2519.0,1474.0,2058.0,1485.0,2530.0,889.0,2392.0,2663.0,1067.0,2917.0,1576.0,1032.0,778.0,1311.0,1843.0,996.0,2850.0,2062.0,814.0,1827.0,1080.0,2361.0]},{&quot;rowKey&quot;:&quot;Row33&quot;,&quot;data&quot;:[34.0,809.0,2138.0,1369.0,801.0,657.0,2108.0,2166.0,2726.0,1889.0,2659.0,2516.0,2483.0,3039.0,2117.0,3192.0,966.0,1208.0,2964.0,1442.0,1780.0,1406.0,2851.0,1093.0,2411.0,2918.0,1711.0,769.0,3169.0,2448.0,1411.0,2121.0,1582.0,2449.0,906.0,2334.0,2713.0,1096.0,2898.0,1583.0,1071.0,792.0,1339.0,1831.0,1039.0,2836.0,2022.0,793.0,1882.0,1085.0,2266.0]},{&quot;rowKey&quot;:&quot;Row34&quot;,&quot;data&quot;:[35.0,782.0,2174.0,1262.0,761.0,724.0,2038.0,2056.0,2679.0,1786.0,2542.0,2461.0,2517.0,2915.0,2125.0,3098.0,854.0,1193.0,2919.0,1450.0,1713.0,1441.0,2925.0,1036.0,2295.0,2789.0,1663.0,761.0,3162.0,2532.0,1405.0,2127.0,1624.0,2485.0,916.0,2356.0,2663.0,1102.0,2894.0,1572.0,1056.0,806.0,1263.0,1774.0,1039.0,2812.0,2018.0,845.0,1881.0,1049.0,2299.0]},{&quot;rowKey&quot;:&quot;Row35&quot;,&quot;data&quot;:[36.0,750.0,2008.0,1262.0,727.0,600.0,2019.0,1954.0,2604.0,1776.0,2529.0,2342.0,2359.0,2854.0,2007.0,2983.0,917.0,1167.0,2846.0,1404.0,1630.0,1366.0,2675.0,941.0,2248.0,2797.0,1632.0,758.0,2893.0,2385.0,1389.0,2010.0,1407.0,2405.0,847.0,2205.0,2614.0,964.0,2806.0,1450.0,985.0,795.0,1283.0,1737.0,1008.0,2667.0,2021.0,754.0,1738.0,1046.0,2198.0]},{&quot;rowKey&quot;:&quot;Row36&quot;,&quot;data&quot;:[37.0,765.0,1891.0,1249.0,758.0,604.0,1944.0,1922.0,2575.0,1761.0,2428.0,2386.0,2338.0,2874.0,2021.0,3032.0,840.0,1170.0,2880.0,1426.0,1574.0,1306.0,2655.0,1011.0,2204.0,2711.0,1550.0,774.0,2974.0,2302.0,1369.0,1998.0,1440.0,2274.0,893.0,2180.0,2527.0,1005.0,2712.0,1437.0,945.0,717.0,1208.0,1707.0,951.0,2762.0,1925.0,767.0,1646.0,983.0,2249.0]},{&quot;rowKey&quot;:&quot;Row37&quot;,&quot;data&quot;:[38.0,734.0,1908.0,1257.0,761.0,579.0,1988.0,1886.0,2665.0,1707.0,2546.0,2347.0,2391.0,2790.0,2008.0,2858.0,849.0,1139.0,2783.0,1380.0,1572.0,1266.0,2818.0,976.0,2216.0,2641.0,1602.0,746.0,2937.0,2293.0,1355.0,1944.0,1454.0,2250.0,855.0,2197.0,2596.0,949.0,2669.0,1423.0,939.0,746.0,1246.0,1648.0,954.0,2663.0,1989.0,703.0,1780.0,962.0,2216.0]},{&quot;rowKey&quot;:&quot;Row38&quot;,&quot;data&quot;:[39.0,731.0,1916.0,1233.0,702.0,626.0,1931.0,1985.0,2544.0,1758.0,2442.0,2343.0,2323.0,2775.0,1985.0,2948.0,861.0,1146.0,2782.0,1356.0,1592.0,1394.0,2756.0,992.0,2243.0,2676.0,1572.0,741.0,2902.0,2438.0,1357.0,1901.0,1499.0,2305.0,864.0,2136.0,2573.0,955.0,2726.0,1474.0,975.0,709.0,1313.0,1730.0,1000.0,2694.0,1959.0,664.0,1732.0,937.0,2231.0]},{&quot;rowKey&quot;:&quot;Row39&quot;,&quot;data&quot;:[40.0,668.0,1858.0,1161.0,709.0,607.0,1841.0,1876.0,2465.0,1597.0,2326.0,2203.0,2173.0,2707.0,1828.0,2773.0,828.0,1063.0,2656.0,1282.0,1528.0,1298.0,2570.0,912.0,2182.0,2621.0,1510.0,744.0,2780.0,2173.0,1297.0,2001.0,1362.0,2200.0,829.0,2091.0,2509.0,1004.0,2520.0,1386.0,967.0,674.0,1171.0,1649.0,957.0,2624.0,1853.0,729.0,1633.0,944.0,2047.0]},{&quot;rowKey&quot;:&quot;Row40&quot;,&quot;data&quot;:[41.0,688.0,1773.0,1106.0,638.0,548.0,1780.0,1831.0,2345.0,1648.0,2227.0,2209.0,2095.0,2655.0,1835.0,2662.0,791.0,1012.0,2678.0,1170.0,1454.0,1205.0,2494.0,914.0,2087.0,2488.0,1495.0,647.0,2718.0,2158.0,1211.0,1864.0,1380.0,2143.0,762.0,2113.0,2323.0,871.0,2562.0,1414.0,941.0,680.0,1178.0,1606.0,885.0,2494.0,1845.0,667.0,1591.0,906.0,2090.0]},{&quot;rowKey&quot;:&quot;Row41&quot;,&quot;data&quot;:[42.0,701.0,1811.0,1143.0,703.0,535.0,1781.0,1860.0,2416.0,1626.0,2352.0,2159.0,2181.0,2696.0,1754.0,2721.0,762.0,1023.0,2684.0,1304.0,1419.0,1249.0,2596.0,935.0,2062.0,2453.0,1508.0,695.0,2694.0,2174.0,1179.0,1858.0,1408.0,2151.0,761.0,2044.0,2450.0,900.0,2551.0,1388.0,928.0,697.0,1138.0,1586.0,890.0,2486.0,1832.0,658.0,1531.0,952.0,1973.0]},{&quot;rowKey&quot;:&quot;Row42&quot;,&quot;data&quot;:[43.0,722.0,1861.0,1121.0,704.0,598.0,1879.0,1851.0,2434.0,1553.0,2294.0,2211.0,2082.0,2694.0,1794.0,2743.0,770.0,1008.0,2645.0,1278.0,1495.0,1266.0,2528.0,970.0,1992.0,2488.0,1479.0,638.0,2817.0,2204.0,1280.0,1876.0,1355.0,2150.0,790.0,2030.0,2414.0,893.0,2456.0,1326.0,949.0,707.0,1144.0,1535.0,908.0,2465.0,1781.0,674.0,1587.0,937.0,2065.0]},{&quot;rowKey&quot;:&quot;Row43&quot;,&quot;data&quot;:[44.0,675.0,1856.0,1162.0,668.0,565.0,1876.0,1835.0,2429.0,1639.0,2391.0,2222.0,2205.0,2582.0,1900.0,2676.0,821.0,1064.0,2686.0,1289.0,1519.0,1266.0,2481.0,912.0,2204.0,2588.0,1472.0,726.0,2863.0,2231.0,1285.0,1907.0,1399.0,2203.0,827.0,2017.0,2356.0,904.0,2547.0,1340.0,966.0,666.0,1141.0,1684.0,903.0,2524.0,1858.0,754.0,1602.0,894.0,2035.0]},{&quot;rowKey&quot;:&quot;Row44&quot;,&quot;data&quot;:[45.0,740.0,1968.0,1202.0,680.0,589.0,2013.0,1909.0,2548.0,1677.0,2412.0,2318.0,2437.0,2853.0,1916.0,2845.0,860.0,1104.0,2874.0,1358.0,1555.0,1334.0,2674.0,969.0,2162.0,2727.0,1631.0,721.0,2995.0,2241.0,1371.0,2032.0,1458.0,2256.0,859.0,2220.0,2570.0,1021.0,2666.0,1498.0,925.0,738.0,1131.0,1626.0,1011.0,2690.0,1967.0,704.0,1781.0,943.0,2225.0]},{&quot;rowKey&quot;:&quot;Row45&quot;,&quot;data&quot;:[46.0,725.0,1984.0,1210.0,764.0,584.0,1869.0,1917.0,2549.0,1629.0,2503.0,2380.0,2442.0,2884.0,1934.0,3007.0,854.0,1068.0,2699.0,1423.0,1596.0,1306.0,2730.0,958.0,2205.0,2722.0,1587.0,751.0,2889.0,2342.0,1295.0,1980.0,1394.0,2354.0,811.0,2180.0,2519.0,987.0,2757.0,1466.0,941.0,780.0,1285.0,1741.0,985.0,2709.0,2026.0,705.0,1650.0,1040.0,2177.0]},{&quot;rowKey&quot;:&quot;Row46&quot;,&quot;data&quot;:[47.0,795.0,1960.0,1270.0,707.0,592.0,1887.0,2058.0,2551.0,1671.0,2453.0,2306.0,2292.0,2826.0,2020.0,2874.0,890.0,1101.0,2799.0,1354.0,1572.0,1322.0,2654.0,1011.0,2224.0,2691.0,1698.0,733.0,2915.0,2297.0,1370.0,1918.0,1457.0,2331.0,851.0,2136.0,2519.0,952.0,2759.0,1484.0,955.0,779.0,1232.0,1686.0,1056.0,2733.0,2006.0,790.0,1692.0,971.0,2142.0]},{&quot;rowKey&quot;:&quot;Row47&quot;,&quot;data&quot;:[48.0,743.0,1957.0,1205.0,724.0,620.0,1923.0,1844.0,2481.0,1767.0,2493.0,2211.0,2275.0,2738.0,1904.0,2913.0,897.0,1055.0,2723.0,1335.0,1543.0,1289.0,2611.0,1031.0,2165.0,2682.0,1503.0,725.0,2843.0,2357.0,1317.0,1854.0,1520.0,2194.0,856.0,2162.0,2534.0,954.0,2602.0,1555.0,934.0,725.0,1167.0,1703.0,951.0,2571.0,1801.0,733.0,1637.0,920.0,2154.0]},{&quot;rowKey&quot;:&quot;Row48&quot;,&quot;data&quot;:[49.0,576.0,1515.0,917.0,609.0,501.0,1545.0,1515.0,2015.0,1288.0,1902.0,1764.0,1824.0,2230.0,1531.0,2243.0,614.0,807.0,2195.0,1052.0,1235.0,1030.0,2087.0,755.0,1678.0,2103.0,1240.0,589.0,2214.0,1764.0,1064.0,1530.0,1162.0,1753.0,665.0,1722.0,1980.0,722.0,2074.0,1041.0,693.0,568.0,929.0,1325.0,761.0,2127.0,1523.0,561.0,1298.0,772.0,1730.0]},{&quot;rowKey&quot;:&quot;Row49&quot;,&quot;data&quot;:[50.0,499.0,1366.0,937.0,520.0,465.0,1426.0,1340.0,1826.0,1236.0,1669.0,1690.0,1580.0,1990.0,1424.0,2093.0,592.0,782.0,2027.0,974.0,1173.0,968.0,1912.0,679.0,1677.0,1976.0,1125.0,516.0,2125.0,1676.0,941.0,1452.0,1109.0,1658.0,649.0,1576.0,1733.0,706.0,2050.0,1034.0,706.0,495.0,898.0,1264.0,676.0,1928.0,1331.0,518.0,1211.0,711.0,1575.0]},{&quot;rowKey&quot;:&quot;Row50&quot;,&quot;data&quot;:[51.0,495.0,1392.0,857.0,523.0,406.0,1376.0,1388.0,1892.0,1171.0,1756.0,1692.0,1705.0,2044.0,1419.0,2049.0,631.0,814.0,1985.0,978.0,1203.0,933.0,1891.0,711.0,1576.0,1941.0,1098.0,496.0,2132.0,1681.0,917.0,1374.0,1057.0,1669.0,614.0,1596.0,1813.0,706.0,1943.0,1096.0,719.0,515.0,942.0,1214.0,723.0,1921.0,1408.0,516.0,1203.0,741.0,1625.0]},{&quot;rowKey&quot;:&quot;Row51&quot;,&quot;data&quot;:[52.0,532.0,1444.0,850.0,540.0,459.0,1419.0,1368.0,1889.0,1216.0,1741.0,1632.0,1657.0,2035.0,1456.0,2144.0,608.0,779.0,2024.0,982.0,1169.0,969.0,1950.0,675.0,1496.0,1913.0,1134.0,560.0,2179.0,1654.0,953.0,1420.0,1085.0,1680.0,621.0,1628.0,1830.0,690.0,1885.0,1090.0,668.0,561.0,821.0,1224.0,688.0,1909.0,1406.0,519.0,1201.0,689.0,1562.0]},{&quot;rowKey&quot;:&quot;Row52&quot;,&quot;data&quot;:[53.0,121.0,288.0,193.0,120.0,97.0,313.0,284.0,396.0,248.0,381.0,359.0,339.0,417.0,301.0,437.0,133.0,167.0,443.0,218.0,247.0,205.0,455.0,151.0,337.0,397.0,209.0,122.0,449.0,342.0,199.0,299.0,203.0,363.0,161.0,351.0,421.0,143.0,405.0,229.0,176.0,118.0,184.0,279.0,171.0,407.0,301.0,114.0,267.0,157.0,328.0]}],&quot;id&quot;:&quot;683a1887-2b26-4b70-9006-5c9ea34b5dd5&quot;,&quot;fragment&quot;:false,&quot;spec&quot;:{&quot;@class&quot;:&quot;org.knime.js.core.JSONDataTableSpec&quot;,&quot;colorModels&quot;:[],&quot;colTypes&quot;:[&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;,&quot;number&quot;],&quot;knimeTypes&quot;:[&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;,&quot;Number (integer)&quot;],&quot;numExtensions&quot;:0,&quot;extensionTypes&quot;:[],&quot;extensionNames&quot;:[],&quot;possibleValues&quot;:[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],&quot;minValues&quot;:[1.0,121.0,288.0,193.0,120.0,97.0,313.0,284.0,396.0,248.0,381.0,359.0,339.0,417.0,301.0,437.0,133.0,167.0,443.0,218.0,247.0,205.0,455.0,151.0,337.0,397.0,209.0,122.0,449.0,342.0,199.0,299.0,203.0,363.0,161.0,351.0,421.0,143.0,405.0,229.0,176.0,118.0,184.0,279.0,171.0,407.0,301.0,114.0,267.0,157.0,328.0],&quot;maxValues&quot;:[53.0,931.0,2459.0,1540.0,929.0,771.0,2416.0,2417.0,3131.0,2105.0,2993.0,2869.0,2977.0,3433.0,2455.0,3688.0,1057.0,1362.0,3502.0,1701.0,1922.0,1665.0,3233.0,1232.0,2759.0,3299.0,1992.0,950.0,3512.0,2883.0,1700.0,2437.0,1790.0,2839.0,1095.0,2754.0,3218.0,1240.0,3314.0,1810.0,1225.0,888.0,1463.0,2126.0,1250.0,3382.0,2372.0,928.0,2160.0,1225.0,2731.0],&quot;rowColorValues&quot;:[&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;,&quot;#404040&quot;],&quot;rowSizeValues&quot;:null,&quot;hiddenColumns&quot;:[],&quot;filterIds&quot;:[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],&quot;containsMissingValues&quot;:[false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false],&quot;colNames&quot;:[&quot;Week&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;22&quot;,&quot;23&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;30&quot;,&quot;31&quot;,&quot;32&quot;,&quot;33&quot;,&quot;34&quot;,&quot;35&quot;,&quot;36&quot;,&quot;37&quot;,&quot;38&quot;,&quot;39&quot;,&quot;40&quot;,&quot;41&quot;,&quot;42&quot;,&quot;43&quot;,&quot;44&quot;,&quot;45&quot;,&quot;46&quot;,&quot;47&quot;,&quot;48&quot;,&quot;49&quot;,&quot;50&quot;],&quot;numColumns&quot;:51,&quot;numRows&quot;:53}}"/>
</config>
</config>
<entry key="warnMessage" type="xstring" value=""/>
<entry key="errorMessage" type="xstring" value=""/>
</config>
